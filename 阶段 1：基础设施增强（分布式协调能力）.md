# 阶段 1：基础设施增强（分布式协调能力）

> 目标：把“单节点可用的 nonce 分配器”推进到“**多节点部署仍然正确**”，并在同一套正确性机制之上支持两种可配置的运行模式：**基础模式** 与 **Worker 队列模式**。

---

## 概要（TL;DR）

这阶段我们只回答一个问题：**多节点同时处理同一个 signer 时，如何保证永远不会重复分配/旧主覆盖新主？**

结论是：

- **正确性基线（所有模式共用）**：任何会写 `signer_nonce_*`（以及后续交易表）的操作，都必须满足：
  1) 先拿到该 signer 的 **租约（lease）**：同一时刻只有一个节点是 owner  
  2) 写入必须携带单调递增的 **fencing token**：数据库拒绝旧 token 写入
- **基础模式（Basic Mode）**：不假设“同 signer 请求会打到同节点”。哪怕请求随机打到任意节点，系统也能正确处理（只是会有更多 lease 争抢/失败重试）。
- **Worker 队列模式（Worker-Queue Mode）**：尽量让同 signer 请求汇聚到同一 worker 节点，并在 worker 内排队串行处理，显著降低 lease 争抢与数据库抖动；但正确性仍然由 lease+fencing 兜底，路由错了最多多一次重试/转发，不会出错。

---

## 目录（读这篇文档的路径）

- **1~2**：把问题“形式化”成不变量（写之前先把正确性说清楚）
- **3~5**：从失败场景推导为什么必须做 lease + fencing（而不是只靠 Redis 锁/随机路由）
- **6~7**：数据模型与核心算法（怎么 acquire/renew、怎么 fenced write）
- **8**：两种运行模式如何共用同一正确性内核（差异只在入口/调度）
- **9**：结合现有代码的最小实现步骤（改哪些类/SQL/配置）
- **10~12**：可观测性、灰度发布、验收测试

---

## 1. 问题定义（把业务变成约束）

我们提供一个能力：对每个 `signer` 分配 nonce（从 0 开始递增，空洞可复用），并提供回写接口 `markUsed/markRecyclable`（语义分别为 `CONSUMED/RELEASED`）。

在单节点里，只要保证“同 signer 串行”就足够。但多节点部署后，会遇到这类真实世界问题：

- 节点 A 卡顿（长 GC/暂停/网络抖动）导致“看起来还活着”，但其实失去了写的资格
- 节点 B 接管后继续推进 nonce
- 节点 A 恢复后仍尝试写入（脑裂/旧主回归）

因此我们要解决的不是“怎么加锁”，而是：

> **如何让任何旧主/失格节点的写入在数据库层面必然失败？**

---

## 2. 正确性不变量（Invariants）

为了让后续设计不跑偏，我们先把必须满足的不变量写出来：

- **I1：单主不变量（Single Owner）**  
  对同一个 signer，在任意时间窗口内最多只有一个节点可以执行“会导致状态推进”的写入。

- **I2：旧主写入隔离（Fencing）**  
  如果发生故障转移（owner 从 A 切到 B），那么 A 在恢复后对该 signer 的所有关键写入都必须被拒绝（不能覆盖 B）。

- **I3：幂等与重试友好**  
  网络抖动/超时导致的重复请求，不应破坏状态（允许同 token 的幂等写入，或通过 request id 等上层机制兜底）。

- **I4：不依赖请求粘性**  
  在基础模式下，不要求“同 signer 的请求一定命中同节点”；系统必须在完全随机路由的情况下仍然正确。

---

## 3. 为什么“仅靠 Redis 分布式锁”不够

即使你有 Redis 锁，也无法从原理上保证 I2（旧主写入隔离）：

- 锁有 TTL，会过期；过期后被新节点获取
- 旧节点可能在锁过期后继续执行并写数据库（它并不知道锁已经丢了）
- 更关键的是：**最终事实在 DB**，如果 DB 接受了旧节点写入，系统就错了

因此：Redis 锁最多是“减少并发”的性能/压力手段，不是多节点正确性的根。

> 本阶段的设计刻意做到：**不需要 Redis 锁也能正确**。Redis 只允许作为可选优化（以后再讨论）。

---

## 4. 从失败场景推导解法：lease + fencing

要满足 I1/I2，最稳的办法是把“谁能写”与“旧主写入隔离”都交给 DB 做最终裁决：

1. **用 DB 租约（lease）回答“谁能写”（I1）**  
   为每个 signer 维护一行 `signer_lease`，字段包含 `owner_node` 与 `expires_at`。

2. **用 fencing token 回答“旧主能不能写”（I2）**  
   当 lease 发生抢占（owner 切换）时，`fencing_token` 单调递增。  
   任何关键写入都带上 token，DB 只接受 **新 token ≥ 旧 token** 的写入。

这样即使节点 A “自以为还能写”，只要它的 token 旧，DB 就会拒绝——从机制上封死脑裂覆盖。

---

## 5. 两种运行模式的关系（先讲清融合逻辑）

这一点很关键：**基础模式**与**Worker 队列模式**不是两套实现。

- 两者共用同一套正确性内核：**lease + fencing + 条件写入**
- 差异只发生在“请求如何到达执行者/如何调度”：
  - 基础模式：不做前置路由，任意节点尝试 acquire，失败就让调用方重试（或网关重试）
  - Worker 队列模式：入口层先把同 signer 的请求尽量汇聚到同一 worker 节点，并在节点内排队串行执行（减少争抢）

> 换句话说：Worker 队列模式是“在正确性内核外面加一层调度/路由”，让系统更快，而不是让系统“才能正确”。

---


