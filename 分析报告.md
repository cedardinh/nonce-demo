# FireFly Transaction Manager - Nonce Management 实现分析

## 1. 核心架构

### 1.1 分层设计

```
Transaction Handler (simple_transaction_handler.go)
    ↓
TransactionPersistence Interface (txhandler.go)
    ↓
    ├── PostgreSQL Implementation (transaction_writer.go)
    └── LevelDB Implementation (nonces.go)
    ↓
FFCAPI - NextNonceForSigner (next_nonce_for_signer.go)
    ↓
Blockchain Node
```

### 1.2 关键接口

```go
// Nonce查询回调
type NextNonceCallback func(ctx context.Context, signer string) (uint64, error)

// 持久化接口
type TransactionPersistence interface {
    InsertTransactionWithNextNonce(ctx context.Context, tx *ManagedTX, 
        lookupNextNonce NextNonceCallback) error
    GetTransactionByNonce(ctx context.Context, signer string, 
        nonce *FFBigInt) (*ManagedTX, error)
}
```

## 2. Nonce分配策略

### 2.1 三级决策机制

```
1. 检查内存缓存 (LRU Cache)
   ├─ 缓存有效 → 使用缓存值
   └─ 缓存无效/不存在
       ↓
2. 查询本地数据库 (Highest Nonce)
   ↓
3. 查询区块链节点 (NextNonceForSigner)
   ↓
4. 取最大值: max(Cache, DB+1, Chain)
```

### 2.2 Nonce状态超时 (nonceStateTimeout)

**配置**: `transactions.nonceStateTimeout` (默认: 1小时)

**决策逻辑**:
```go
if time.Since(lastTx.Created) < nonceStateTimeout {
    // 本地状态新鲜，直接使用
    nextNonce = lastTx.Nonce + 1
} else {
    // 本地状态过期，查询区块链
    nextNonce = max(chainNonce, lastTx.Nonce + 1)
}
```

## 3. PostgreSQL实现

### 3.1 数据结构

```go
// Nonce缓存条目
type nonceCacheEntry struct {
    cachedTime *FFTime  // 缓存时间
    nextNonce  uint64   // 下一个nonce
}

// 交易写入器
type transactionWriter struct {
    nextNonceCache *lru.Cache[string, *nonceCacheEntry]  // Key: signer
    workerCount    uint32                                 // Worker数量
    workQueues     []chan *transactionOperation          // 工作队列
    batchTimeout   time.Duration                         // 批次超时
    batchMaxSize   int                                   // 批次大小
}
```

### 3.2 并发控制：Worker路由

```go
// 哈希路由确保同一签名者到同一worker
hashKey := operation.From  // 签名者地址
h := fnv.New32a()
h.Write([]byte(hashKey))
workerIndex := h.Sum32() % workerCount

// 发送到目标worker
workQueues[workerIndex] <- operation
```

**关键特性**:
- 同一签名者的所有交易路由到同一worker
- 保证nonce分配的串行化
- 不同签名者可以并行处理

### 3.3 Nonce分配算法 (assignNonces)

```go
func assignNonces(ctx, txInsertsByFrom map[string][]*operation) error {
    for signer, txs := range txInsertsByFrom {
        // 1. 检查缓存
        cacheEntry, isCached := nextNonceCache.Get(signer)
        cacheExpired := time.Since(cacheEntry.cachedTime) > nonceStateTimeout
        
        for _, op := range txs {
            if cacheEntry == nil || cacheExpired {
                // 2. 查询区块链
                chainNonce := op.nextNonceCB(ctx, signer)
                
                var internalNonce uint64
                if cacheEntry != nil {
                    // 使用过期缓存值（未提交批次）
                    internalNonce = cacheEntry.nextNonce
                } else {
                    // 查询数据库最高nonce
                    lastTx := db.Query("SELECT * FROM txs WHERE from=? ORDER BY nonce DESC LIMIT 1")
                    internalNonce = lastTx.Nonce + 1
                }
                
                // 3. 取最大值
                if internalNonce > chainNonce {
                    chainNonce = internalNonce
                }
                
                // 4. 更新缓存
                cacheEntry = &nonceCacheEntry{
                    cachedTime: now(),
                    nextNonce: chainNonce,
                }
            }
            
            // 5. 分配nonce并递增
            op.txInsert.Nonce = cacheEntry.nextNonce
            cacheEntry.nextNonce++
            nextNonceCache.Add(signer, cacheEntry)
        }
    }
}
```

### 3.4 批量处理优化

```go
// Worker批处理机制
for {
    select {
    case op := <-workQueue:
        // 累积操作
        batch.ops = append(batch.ops, op)
        
    case <-timeout:
        // 批量执行
        runBatch(batch)
        batch = nil
    }
    
    // 触发条件: 大小达标 或 超时
    if len(batch.ops) >= batchMaxSize || timeout {
        runBatch(batch)
    }
}
```

**批量优势**:
- 同一批次中同签名者的多个交易只查询一次区块链
- 单个数据库事务插入多个交易
- Nonce连续分配 (100, 101, 102...)

### 3.5 失败恢复

```go
func runBatch(ctx, batch) {
    err := db.RunAsGroup(func() {
        assignNonces(ctx, batch.txInsertsByFrom)  // 分配nonce
        insertTransactions(ctx, batch.txInserts)   // 插入交易
    })
    
    if err != nil {
        // 清理失败批次的缓存
        clearCachedNonces(ctx, batch.txInsertsByFrom)
        // 所有操作返回错误
        for _, op := range batch.ops {
            op.done <- err
        }
    }
}
```

## 4. LevelDB实现

### 4.1 数据结构

```go
type leveldbPersistence struct {
    nonceMux     sync.Mutex                 // 全局nonce锁
    lockedNonces map[string]*lockedNonce    // Key: signer
}

type lockedNonce struct {
    signer   string
    unlocked chan struct{}  // 等待/唤醒通道
    nonce    uint64
    spent    bool
}
```

### 4.2 并发控制：互斥锁 + 通道

```go
func assignAndLockNonce(ctx, signer, nextNonceCB) (*lockedNonce, error) {
    for {
        nonceMux.Lock()
        locked, isLocked := lockedNonces[signer]
        
        if !isLocked {
            // 创建锁对象
            locked = &lockedNonce{
                signer: signer,
                unlocked: make(chan struct{}),
            }
            lockedNonces[signer] = locked
            doLookup = true
        }
        nonceMux.Unlock()
        
        if isLocked {
            // 等待其他goroutine释放锁
            <-locked.unlocked
            // 循环重试
        } else if doLookup {
            // 计算nonce
            locked.nonce = calcNextNonce(ctx, signer, nextNonceCB)
            return locked, nil
        }
    }
}
```

**使用模式**:
```go
locked, err := assignAndLockNonce(ctx, signer, callback)
if err != nil {
    return err
}
defer locked.complete(ctx)  // 确保释放锁

// 使用nonce
tx.Nonce = locked.nonce
locked.spent = true
```

### 4.3 Nonce计算算法 (calcNextNonce)

```go
func calcNextNonce(ctx, signer, nextNonceCB) (uint64, error) {
    // 1. 查询本地最后一个交易
    lastTx := db.ListTransactionsByNonce(signer, nil, 1, DESC)[0]
    
    if lastTx != nil {
        // 2. 检查是否在超时内
        if time.Since(lastTx.Created) < nonceStateTimeout {
            // 本地状态新鲜
            return lastTx.Nonce + 1, nil
        }
    }
    
    // 3. 查询区块链
    chainNonce := nextNonceCB(ctx, signer)
    
    // 4. 保护机制：防止重用已有nonce
    if lastTx != nil && chainNonce <= lastTx.Nonce {
        chainNonce = lastTx.Nonce + 1
    }
    
    return chainNonce, nil
}
```

### 4.4 锁释放机制

```go
func (ln *lockedNonce) complete(ctx) {
    nonceMux.Lock()
    
    // 1. 从映射删除锁
    delete(lockedNonces, ln.signer)
    
    // 2. 关闭通道，唤醒所有等待者
    close(ln.unlocked)
    
    nonceMux.Unlock()
}
```

## 5. Transaction Handler层

### 5.1 交易创建与Nonce分配

```go
func createManagedTx(ctx, txID, txHeaders, gas, data) (*ManagedTX, error) {
    mtx := &ManagedTX{
        ID: txID,
        TransactionHeaders: *txHeaders,
        Status: TxStatusPending,
    }
    
    // 核心: 在nonce锁内持久化
    err := TXPersistence.InsertTransactionWithNextNonce(ctx, mtx, 
        func(ctx, signer string) (uint64, error) {
            // 查询区块链
            res, _, err := Connector.NextNonceForSigner(ctx, 
                &NextNonceForSignerRequest{Signer: signer})
            return res.Nonce.Uint64(), err
        })
    
    if err == nil {
        // 记录nonce分配历史
        TXHistory.AddSubStatusAction(ctx, txID, 
            TxSubStatusReceived, 
            TxActionAssignNonce,
            JSON{"nonce": mtx.Nonce}, 
            nil, now())
    }
    
    return mtx, err
}
```

### 5.2 交易提交

```go
func submitTX(ctx *RunContext) (reason, error) {
    sendTX := &TransactionSendRequest{
        TransactionHeaders: mtx.TransactionHeaders,
        GasPrice: mtx.GasPrice,
        TransactionData: mtx.TransactionData,
    }
    sendTX.TransactionHeaders.Nonce = mtx.Nonce  // 使用分配的nonce
    
    res, reason, err := Connector.TransactionSend(ctx, sendTX)
    
    if err != nil {
        switch reason {
        case ErrorReasonNonceTooLow, ErrorKnownTransaction:
            if mtx.TransactionHash != "" {
                // 已有hash，视为成功
                return "", nil
            }
        }
        return reason, err
    }
    
    mtx.TransactionHash = res.TransactionHash
    return "", nil
}
```

## 6. 错误处理

### 6.1 Nonce相关错误

**ErrorReasonNonceTooLow**: 提交的nonce已被使用

```go
// 处理策略
if reason == ErrorReasonNonceTooLow {
    if mtx.TransactionHash != "" {
        // 已有hash，不是真正的错误
        return nil
    }
    return err  // 否则返回错误
}
```

**发生场景**:
- 多系统共享密钥
- 手动发送相同nonce的交易
- 交易池状态不同步

**预防措施**:
- 单一nonce管理源
- 设置较小的`nonceStateTimeout`
- 监控nonce分配日志

### 6.2 缓存清理机制

```go
// PostgreSQL: 批次失败时清理
if batchInsertFailed {
    clearCachedNonces(ctx, txInsertsByFrom)
    // 下次请求重新查询
}

// LevelDB: 错误时自动释放锁
locked, err := assignAndLockNonce(...)
if err != nil {
    locked.complete(ctx)  // 确保释放
    return nil, err
}
```

## 7. 配置参数

### 7.1 核心配置

```yaml
transactions:
  nonceStateTimeout: 1h  # Nonce状态有效期

persistence:
  postgres:
    transactionWriter:
      workerCount: 10      # Worker数量
      batchSize: 100       # 批次大小
      batchTimeout: 50ms   # 批次超时
      cacheSlots: 1000     # LRU缓存大小
```

### 7.2 配置场景

**单一nonce管理源 (推荐)**:
```yaml
nonceStateTimeout: 1h  # 默认值，性能最优
```

**多系统共享密钥**:
```yaml
nonceStateTimeout: 100ms  # 接近0，减少冲突窗口
```

**高吞吐量**:
```yaml
workerCount: 5
batchSize: 500
batchTimeout: 200ms
```

**低延迟**:
```yaml
workerCount: 20
batchSize: 50
batchTimeout: 25ms
```

## 8. 实现对比

| 特性 | PostgreSQL | LevelDB |
|------|-----------|---------|
| **并发模型** | Worker队列 + 批处理 | 互斥锁 + 通道等待 |
| **路由机制** | FNV哈希路由 | 每个签名者独立锁 |
| **缓存策略** | LRU缓存 + 超时 | 无缓存 |
| **批量优化** | ✅ 支持 | ❌ 单个处理 |
| **性能** | 高并发场景优秀 | 简单场景足够 |
| **复杂度** | 较高 | 较低 |
| **适用场景** | 生产环境、高并发 | 开发测试、简单部署 |

## 9. 关键设计原则

### 9.1 顺序性保证

- **PostgreSQL**: 哈希路由确保同一签名者到同一worker
- **LevelDB**: 互斥锁确保同一签名者串行处理

### 9.2 安全性

```
finalNonce = max(chainNonce, cachedNonce, dbNonce + 1)
```

- 防止nonce重用
- 保护pending交易
- 应对节点状态不一致

### 9.3 性能优化

**PostgreSQL批量处理**:
- 100个相同签名者的交易 → 1次区块链查询
- 单个数据库事务 → 减少开销
- LRU缓存 → 命中率高时无需查询

**LevelDB通道等待**:
- 避免自旋等待
- 阻塞式等待 → CPU友好
- 锁粒度细 → 不同签名者并行

### 9.4 容错性

- 批次失败 → 清理缓存
- 查询失败 → 返回错误，上层重试
- 锁异常 → 自动释放，防止死锁

## 10. 数据流

### 10.1 完整流程

```
1. 上层调用 HandleNewTransaction
   ↓
2. Transaction Handler: createManagedTx
   ↓
3. InsertTransactionWithNextNonce(tx, callback)
   ↓
4. [PostgreSQL] 路由到worker → 加入批次
   [LevelDB] 获取签名者锁
   ↓
5. [PostgreSQL] assignNonces(batch)
   [LevelDB] calcNextNonce(signer)
   ↓
6. 检查缓存/数据库
   ↓
7. 调用callback查询区块链 (NextNonceForSigner)
   ↓
8. 比较三方值，取最大
   ↓
9. 分配nonce到交易对象
   ↓
10. [PostgreSQL] 批量插入数据库
    [LevelDB] 插入数据库 + 释放锁
   ↓
11. 返回已分配nonce的交易
   ↓
12. 记录历史: TxActionAssignNonce
   ↓
13. submitTX: 使用nonce提交到区块链
```

### 10.2 并发场景

**PostgreSQL (3个并发请求, 同一签名者)**:
```
Request1: "0xAAA" → hash → Worker[2] → Batch[A]
Request2: "0xAAA" → hash → Worker[2] → Batch[A]
Request3: "0xAAA" → hash → Worker[2] → Batch[A]

Worker[2] 执行:
- 查询区块链一次: nonce=100
- 分配: tx1=100, tx2=101, tx3=102
- 批量插入数据库
```

**LevelDB (3个并发请求, 同一签名者)**:
```
Goroutine1: lock(0xAAA) → calcNonce → 100 → unlock
                ↓ (blocking)
Goroutine2: wait on <-unlocked ┘
                ↓ (blocking)
Goroutine3: wait on <-unlocked ┘

完成顺序:
1. G1: nonce=100, unlock → close(unlocked)
2. G2/G3: 被唤醒, 重新竞争锁
3. G2: nonce=101, unlock
4. G3: nonce=102, unlock
```

## 11. 核心代码位置

| 功能 | PostgreSQL | LevelDB |
|------|-----------|---------|
| **Nonce分配** | `transaction_writer.go:377-569` | `nonces.go:262-385` |
| **并发控制** | `transaction_writer.go:144-242` | `nonces.go:131-239` |
| **缓存管理** | `transaction_writer.go:60-63` | N/A |
| **批处理** | `transaction_writer.go:185-317` | N/A |
| **锁管理** | N/A | `nonces.go:28-112` |
| **入口** | `simple_transaction_handler.go:320-417` | 同左 |

## 12. 总结

### 核心机制

1. **三级决策**: Cache → DB → Chain → max()
2. **并发控制**: 
   - PostgreSQL: Worker路由 + 批处理
   - LevelDB: 互斥锁 + 通道等待
3. **超时策略**: nonceStateTimeout决定是否信任本地状态
4. **失败恢复**: 清理缓存 + 重新查询

### 设计亮点

- ✅ 保证nonce严格递增，无gap
- ✅ 批量优化减少区块链查询
- ✅ 确定性路由保证顺序
- ✅ max()策略防止重用
- ✅ 失败时自动清理状态

### 适用场景

**PostgreSQL实现**:
- 生产环境
- 高并发（多签名者）
- 需要批量处理
- 对性能要求高

**LevelDB实现**:
- 开发测试
- 简单部署
- 低并发
- 无持久化数据库需求

