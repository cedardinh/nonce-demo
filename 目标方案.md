## 最终目标方案（稳定优先）

> 本方案融合 `firefly方案.md`、`方案1111.md` 以及 FireFly FFTM 的实现思路，面向 **多节点部署** 与 **故障转移**，以“稳定 > 性能”为第一原则。

---

## 1. 关键结论（先把边界说死）

### 1.1 我们能严格保证
- **不重复分配 nonce**：同一 signer 的 nonce 分配在任意时刻只有一个 leader 能写入（lease + fencing）。
- **不回退**：每个 signer 的本地游标单调递增（fenced 更新），且所有状态回写幂等/有序。
- **可查可监控**：每个已分配 nonce 都有权威记录与状态机轨迹（txId、nonce、txHash、receipt、confirmations、重试次数等）。

### 1.2 我们不能做硬保证的点（由业务约束决定）
- **链上绝对不跳号（无 gap）**：你们明确禁止系统自动取消/替换/填洞交易，因此无法提供“链上永不出现 gap”的硬保证。
  - 我们能保证：系统不会悄悄放弃某个 nonce，会持续追踪与重播同一笔业务交易，并在超时/异常时升级为人工介入。
  - 若某个 nonce 永久无法被链消耗，后续 nonce 会被链规则阻塞，这是链的规则。

---

## 2. 借鉴 FireFly 的核心思想（取其稳定性）

### 2.1 同 signer 串行化是第一性原理
- FFTM Postgres 的 `transaction_writer` 用“按 signer 路由到同一 worker + 批处理”实现串行化与高吞吐。
- 我们在多节点场景把串行化边界升级为：集群内同 signer 只有一个 leader（lease + fencing），节点内再用 worker 串行化减少 DB 冲突。

### 2.2 提交与终局解耦
- FFTM 不把提交成功拿到 txHash 当终局，终局由 `receipt_checker + confirmations` 后台推进。
- 我们同样采用：提交只产生 txHash 与 Tracking，终局由后台确认器推进到 Confirmed（或失败）。

### 2.3 newFork 协议：重组必然存在，必须允许回退与覆盖
- FFTM 的 `dispatchConfirmations()` 在检测到 confirmations 前缀 hash 不一致时 `newFork=true`，下游全量覆盖。
- 我们同样使用该协议：确认列表可替换，避免重组后误判终局。

### 2.4 不让慢下游拖死系统
- FFTM 的 blocklistener buffer 会在下游阻塞时丢通知并标记 GapPotential，避免全局停摆。
- 我们在实现上采用同类思想：关键路径不被确认/回调阻塞（异步队列 + 有界背压 + 告警）。

---

## 3. 架构（稳定优先的最小复杂度）

### 3.1 权威与非权威
- **权威**：PostgreSQL（交易、nonce 游标、lease/fencing、receipt、confirmations、调度时间、错误信息）
- **非权威（可选）**：Redis 仅用于缓存/延迟队列（不影响正确性）；稳定优先可先不引入

### 3.2 组件划分
- **API/UseCase**
  - CreateTx：幂等创建 + 触发提交（返回 txId/nonce）
  - QueryTx：查询状态与追踪信息
- **Leader-only 后台**
  - ReceiptChecker：异步拉 receipt（不阻塞主流程）
  - ConfirmationManager：确认数推进 + reorg/newFork
  - Resubmitter：超时重播同一笔业务交易（同 nonce、同 payload）
- **节点内串行化**
  - WorkerPool：`hash(signer)%N` 路由到单线程 worker，减少同 signer 内部并发与 DB 冲突

---

## 4. 数据模型（权威落在 Postgres）

### 4.1 signer_lease（强制）
- 字段：`signer, owner_node, fencing_token, expires_at`
- 语义：
  - 抢占 lease 时 `fencing_token++`
  - 任何关键写入必须携带 fencing_token 校验

### 4.2 managed_tx（建议：交易即 nonce 载体）
必须包含：
- **幂等**：`(signer, request_id)` 唯一（若 request_id 存在）
- **nonce 与链上追踪**：`nonce, tx_hash, last_submit_at, next_resubmit_at`
- **终局证据**：`receipt, confirmations, confirmed_at`
- **执行权绑定**：`fencing_token`（写入时必须与 signer_lease 匹配）
- **状态机**：`state, sub_state, error_message`

推荐状态：
- `ALLOCATED`：已分配 nonce
- `TRACKING`：已提交（有 tx_hash）
- `CONFIRMED`：达到终局阈值（N confirmations / SAFE / FINALIZED）
- `FAILED_FINAL`：receipt 显示失败且已消耗 nonce（可终止）
- `STUCK`：长期无法终局（不终止，强告警 + 人工介入）

### 4.3 signer_nonce_cursor（建议）
- 字段：`signer, next_nonce, fencing_token`
- 语义：单调递增，仅 leader 可 fenced 更新

---

## 5. 关键算法与流程（按 FireFly 思路落地）

### 5.1 分布式执行权（lease + fencing）
- acquireOrRenew：`SELECT ... FOR UPDATE`，续租或抢占，抢占则 token++
- **fenced 写入规则**：所有关键更新都必须校验：
  - lease 未过期
  - owner_node == self
  - fencing_token == token
- 若 fenced（影响行数=0）：立即停止该 signer 的处理，等待下一轮抢租

### 5.2 nonce 分配（稳定优先的规则）
- 默认：以 `signer_nonce_cursor.next_nonce` 为主（单调递增）
- 可选：若 signer 可能被外部系统使用，则定期参考链上 `pending nonce`（`max(dbNext, chainNext)`），以减少 nonce too low 冲突

### 5.3 提交与幂等（对应 FFTM 的 known tx / nonce too low）
- 提交成功：写入 `tx_hash`，进入 `TRACKING`
- 提交失败但 reason 属于 `known_transaction / nonce_too_low`：
  - 若本地已有 tx_hash：视为幂等成功（防止重复提交误判失败）
  - 若本地无 tx_hash：灰区 → 进入 `STUCK` 候选并强告警（需要人工或增强 connector 能力解决）

### 5.4 ReceiptChecker（异步队列，不阻塞主路径）
- NotFound：表示未就绪，更新 lastReceiptCheck，稍后重试
- 非 NotFound 错误：退避 + 放回队尾，避免单条卡死与紧密自旋

### 5.5 ConfirmationManager（确认数 + newFork 覆盖协议）
- 收到 receipt 后记录 `blockNumber/blockHash`
- 走链回溯累计 confirmations（验证 parentHash）
- `newFork`：若 confirmations 前缀 hash 不一致，则覆盖写 confirmations（而非追加）
- 达到阈值：进入 `CONFIRMED`

### 5.6 Resubmitter（同交易重播，禁止替换/取消）
- 条件：`now - last_submit_at > resubmit_interval` 且 receipt 仍为空（或未达阈值）
- 动作：重播同一笔业务交易（同 nonce、同 payload、同签名产物）
- 注意：不做 gas bump/替换交易（业务约束）
- 结果：
  - 成功或幂等接受：更新 `last_submit_at/next_resubmit_at`
  - 反复失败：进入 `STUCK` 并告警（不终止，不放弃 nonce）

---

## 6. 全流程预演（从创建到终局）

### 6.1 正常路径
1. CreateTx 到达任意节点 → worker 路由到 signer worker
2. worker 抢租成功（token=T）→ 幂等校验 → 分配 nonce（fenced 更新 cursor）→ 写入 managed_tx（state=ALLOCATED, token=T）
3. submit → 返回 txHash → fenced 写入 txHash（state=TRACKING）
4. ReceiptChecker 拉到 receipt → fenced 写入 receipt
5. ConfirmationManager 累积 confirmations，达到 required → fenced 写入 CONFIRMED

### 6.2 节点故障切换（旧节点迟到回写）
1. 节点 A 持 token=10，宕机或失联导致 lease 过期
2. 节点 B 抢占 token=11
3. A 恢复后尝试回写：fenced 更新影响行数=0 → 回写失败，避免污染（必须的硬切断）

### 6.3 链重组（newFork）
1. 已写入部分 confirmations
2. 发生 reorg：后续确认链 parentHash 不一致
3. ConfirmationManager 生成新 confirmations，标记 `newFork=true`
4. 覆盖旧 confirmations，避免拼接两条分叉确认链误判终局

### 6.4 长期 pending / receipt 不可得
1. ReceiptChecker 多次 NotFound
2. 到 resubmit_interval → Resubmitter 重播同交易
3. 若长期仍无 receipt → 标记 `STUCK` + 强告警 + 人工介入（不替换/不取消/不放弃 nonce）

---

## 7. 风险与漏洞检查（第一轮）+ 方案内优化

### 7.1 风险：双活窗口（路由抖动/网络分区）
- **后果**：两个节点同时处理同 signer，导致重复分配/重复 resubmit/乱回写
- **缓解**：lease + fencing（所有关键写 fenced），非 leader 只能读或直接拒绝

### 7.2 风险：已提交但未记录 txHash（灰区）
- **后果**：可能重复提交，同 nonce 行为不确定，难追踪
- **缓解**
  - 强约束：提交接口必须返回 txHash 才算提交成功
  - 或增强 connector：支持重算 txHash / txpool 查询（后续增强）
  - 当前方案：落入 `STUCK` 告警，人工处理（稳定优先）

### 7.3 风险：确认回写与 lease 切换并发
- **后果**：旧节点根据旧链视图回写 confirmations 覆盖新节点
- **缓解**：confirmations/receipt 回写也必须 fenced；旧 token 回写失败

### 7.4 风险：队列堆积导致系统反压
- **后果**：receipt/confirmations backlog 增大，延迟飙升
- **缓解**
  - 队列有界 + 告警
  - worker 数与 staleReceiptTimeout 可调
  - 关键路径不等待后台（异步）

### 7.5 风险：时钟漂移导致 lease 误判
- **后果**：节点本地时间不准导致“误以为 lease 未过期/已过期”，引发抖动或双活
- **缓解**
  - 以 **DB 时间**为准（所有过期判断用 `now()` 在 SQL 内完成）
  - 引入 `clockSkewAllowance`（例如 1s），续租间隔 `< duration/2`

### 7.6 风险：leader 崩溃在“发出 RPC”前后导致重复动作
- **后果**：resubmit 或 submit 可能重复触发（同一笔交易被重播多次）
- **缓解**
  - 所有“可能外部副作用”的动作都先在 DB 内 **claim**（原子更新 `next_resubmit_at` 或写入 `last_submit_at` 的期望值），再发 RPC
  - 即使重复重播，也要求 connector/链侧对“同 txHash/同 payload”具备幂等接受能力（known_transaction）

### 7.7 风险：同 signer 并发窗口过大导致后续交易全部堆在 pending
- **后果**：前序 nonce 卡住（无 receipt）时，后续 nonce 交易都会被链规则阻塞，系统表面吞吐高但实际全部 pending
- **缓解（稳定优先默认）**
  - 强制 `maxInFlight=1`（同 signer 同时只允许 1 笔 TRACKING/ALLOCATED）
  - 需要更高并发时必须先接受“会堆积”的监控与运维成本

---

## 8. 二次复核（仍需你补充决策的点）

> 以下不是设计漏洞，而是必须由你们业务/链环境给出参数或策略选择的部分。

1. **终局阈值选择**：N confirmations / SAFE / FINALIZED 的目标到底是哪一个
2. **STUCK 的处置流程**：多久算 stuck、谁来处理、允许人工做哪些操作
3. **是否允许并发窗口 >1**：稳定优先建议同 signer `maxInFlight=1`
4. **链上 nextNonce 查询策略**：是否存在外部系统也用同 signer（决定是否要 max(chain, db)）

---

## 9. 二次复核结论（本方案在当前约束下仍然可能的残余缺陷）

> 这些缺陷不是实现疏漏，而是你们的业务约束（禁止替换/取消/填洞）带来的“不可消除风险”，需要显式接受并形成 SOP。

1. **永久 STUCK 会阻塞该 signer 的所有后续交易**：如果某 nonce 永久无法被链消耗，而你们又不允许替换/取消，只能长期卡住并人工处理。
2. **灰区 txHash 丢失无法完全自动修复**：没有“重算 txHash/txpool 查询”的 connector 能力时，只能告警人工介入。
3. **多源 signer 使用会显著降低稳定性**：如果同 signer 被外部系统使用，即使 max(chain, db) 也只能降低冲突概率，不能给出强一致保证；建议强约束“单一管理源”。

