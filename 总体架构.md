flowchart TB
    %% ========= 第 1 层：对外接口与业务编排 =========
    subgraph L1["第 1 层：对外接口与业务编排"]
        Client["客户端 / 业务系统"]
        Ctrl["接口层（Controller）\n示例：发起交易 / 查询记录"]
        Svc["业务服务层（Service）\n- 组装参数\n- 调用执行模板"]
    end

    %% ========= 第 2 层：执行模板 =========
    subgraph L2["第 2 层：Nonce 执行模板"]
        Tpl["执行模板（NonceExecutionTemplate）\n固定流程：申请 nonce → 执行业务 → 更新状态"]
        Handler["业务 Handler\n真正的业务逻辑（如调用链上 / 下游服务）"]
        ResultProc["结果处理器（NonceResultProcessor）\n把业务结果映射为：已使用 / 可回收 等"]
    end

    %% ========= 第 3 层：引擎管理 =========
    subgraph L3["第 3 层：引擎管理与模式路由"]
        EngineMgr["引擎管理器（NonceEngineManager）\n统一入口：分配 / 标记使用 / 标记回收\n按模式路由到不同引擎"]
        ModeCtrl["模式管理接口\n运维：查询模式 / 切换模式"]
        HealthView["引擎健康视图\n当前模式 + 关键健康指标"]
    end

    %% ========= 第 4 层 A：可靠模式 =========
    subgraph L4A["第 4 层 A：可靠模式（数据库主导，全部同步落库）"]
        R_Engine["可靠引擎（ReliableNonceEngine）\n在数据库事务中完成分配和更新"]
        R_Lock["按用户加锁协调器\n使用 Redis 分布式锁\n保证同一用户串行"]
        R_Repo["数据库访问层\n读取/初始化用户状态 + 写入各类记录"]
        R_State["用户状态（状态表）\n- 链上已确认到哪个 nonce\n- 本地下一待发 nonce"]
        DB["关系型数据库\n持久化所有状态与明细"]
    end

    %% ========= 第 4 层 B：性能模式 =========
    subgraph L4B["第 4 层 B：性能模式（Redis 主导 + 异步刷盘）"]
        P_Engine["性能引擎（PerformanceNonceEngine）\n主写 Redis，快速返回\n出问题可降级"]
        P_Lock["按用户加锁协调器\n在性能模式下也保持串行"]
        P_Pool["可复用池（Redis）\n存放“可回收 nonce”，优先复用"]
        P_Counter["分配计数器（Redis）\n无可复用时，自增生成新号\n初始值与数据库对齐"]
        P_Cache["分配快照缓存（Redis）\n记录各 nonce 的当前状态\n支持恢复与对账"]
        P_Queue["刷盘队列（Redis 列表）\n主队列 + 待确认队列\n承载“预留 / 已用 / 可回收”等事件"]
        P_Worker["刷盘任务（定时执行）\n批量从队列取事件\n在单个事务中写入数据库"]
        P_Health["性能链路健康信息\nRedis / 刷盘 / 队列堆积情况"]
    end

    %% ========= 第 5 层：后台任务与监控 =========
    subgraph L5["第 5 层：后台任务与监控"]
        Cleanup["数据清理任务\n定期清理历史记录\n控制表大小与查询成本"]
        Monitor["监控与告警系统\n关注健康指标与队列长度\n触发告警 / 人工干预"]
    end

    %% =========== 场景①：完整业务调用链（蓝色） ===========
    Client -->|"①-1 发起请求：调用发交易接口"| Ctrl
    Ctrl -->|"①-2 调用业务服务层"| Svc
    Svc -->|"①-3 交给执行模板处理"| Tpl
    Tpl -->|"①-4 申请 nonce（分配号段）"| EngineMgr
    Tpl -->|"①-5 携带 nonce 执行业务逻辑"| Handler
    Handler -->|"①-6 返回业务执行结果"| Tpl
    Tpl -->|"①-7 将结果交给结果处理器"| ResultProc
    ResultProc -->|"①-8 根据结果要求，引擎更新 nonce 状态"| EngineMgr

    %% =========== 场景②：可靠模式内部流程（绿色） ===========
    EngineMgr -->|"②-1 可靠模式：调用可靠引擎处理"| R_Engine
    R_Engine -->|"②-2 为该用户获取分布式锁"| R_Lock
    R_Lock -->|"②-3 在持锁期间开启数据库事务\n执行分配或状态更新"| R_Repo
    R_Repo -->|"②-4 读取或初始化用户状态"| R_State
    R_State -->|"②-5 生成或复用合适的 nonce\n并更新本地计数信息"| R_Repo
    R_Repo -->|"②-6 写入 RESERVED / USED / RECYCLABLE\n并持久化到数据库"| DB

    %% =========== 场景③：性能模式分配流程（橙色） ===========
    EngineMgr -->|"③-1 性能模式：调用性能引擎处理"| P_Engine
    P_Engine -->|"③-2 为该用户加锁（Redis 锁）"| P_Lock
    P_Engine -->|"③-3 优先从可复用池中取出一个可用 nonce"| P_Pool
    P_Engine -->|"③-4 若无可复用，则通过分配计数器生成新 nonce"| P_Counter
    P_Engine -->|"③-5 记录本次分配的快照到 Redis 缓存"| P_Cache
    P_Engine -->|"③-6 将“预留/已用/可回收”等事件投递到刷盘队列"| P_Queue

    %% =========== 场景④：性能模式异步刷盘（红色） ===========
    P_Queue -->|"④-1 定时批量取出待刷盘事件"| P_Worker
    P_Worker -->|"④-2 在单个数据库事务中\n写入/更新相关记录（预留/已用/可回收）"| DB
    P_Worker -->|"④-3 写入成功后：确认事件\n并通知性能引擎可清理部分缓存"| P_Engine
    P_Worker -->|"④-4 写入失败：事件退回队列\n等待下一轮重试"| P_Queue
    P_Worker -->|"④-5 记录本次成功/失败信息\n更新健康状态"| P_Health

    %% =========== 场景⑤：运维、监控与清理（紫色） ===========
    ModeCtrl -->|"⑤-1 运维：查询/切换引擎模式"| EngineMgr
    EngineMgr -->|"⑤-2 暴露当前模式和健康信息"| HealthView
    Monitor -->|"⑤-3 读取健康信息，判断是否异常"| HealthView
    Monitor -->|"⑤-4 结合性能健康指标，决定是否告警/干预"| P_Health
    Cleanup -->|"⑤-5 定期清理历史数据，控制表大小"| DB

    %% =========== 各场景连线颜色定义 ===========
    %% 场景①：蓝色
    linkStyle 0,1,2,3,4,5,6,7 stroke:#1f77b4,stroke-width:2px;
    %% 场景②：绿色
    linkStyle 8,9,10,11,12,13 stroke:#2ca02c,stroke-width:2px;
    %% 场景③：橙色
    linkStyle 14,15,16,17,18,19 stroke:#ff7f0e,stroke-width:2px;
    %% 场景④：红色
    linkStyle 20,21,22,23,24 stroke:#d62728,stroke-width:2px;
    %% 场景⑤：紫色
    linkStyle 25,26,27,28,29 stroke:#9467bd,stroke-width:2px;





    ----
场景①（蓝色）：一次完整业务调用链，从 HTTP 请求到状态更新
场景②（绿色）：可靠模式（数据库主导）内部怎么分配和更新
场景③（橙色）：性能模式（Redis 主导）如何快速分配 nonce
场景④（红色）：性能模式的异步刷盘落库
场景⑤（紫色）：运维、监控、数据清理