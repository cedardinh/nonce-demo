# Nonce 管理系统演进计划

> 基于当前项目现状 + FireFly Transaction Manager 方案 + 分布式租约架构的综合演进路线图

---

## 一、当前系统现状分析

### 1.1 已有能力 ✅

- ✅ 基础的 nonce 分配（RESERVED → USED → RECYCLABLE）
- ✅ Redis 锁 + Postgres 事务的并发控制
- ✅ 空洞复用机制
- ✅ 过期 RESERVED 自动回收
- ✅ NonceExecutionTemplate 封装执行流程
- ✅ 基本的状态机管理

### 1.2 核心缺失能力 ❌

#### 分布式协调层面
- ❌ **无分布式租约机制**：只有 Redis 锁，无法防止脑裂
- ❌ **无 fencing token**：故障转移时旧节点可能覆盖新节点写入
- ❌ **无按 signer 路由**：缺少"同 signer 打到同节点"的路由层

#### Nonce 分配层面
- ❌ **未对齐链上 nonce**：没有实现 `max(chain, cache, db)` 三级决策
- ❌ **无 nonce 缓存机制**：每次都查 DB，性能不佳
- ❌ **缺少批量分配**：FireFly 的 batch writer 模式未采用

#### 终局确认层面
- ❌ **无 receipt 跟踪系统**：分配后不知道交易是否真正上链
- ❌ **无确认数机制**：无法判断 N 次确认后的终局
- ❌ **无重组检测**：链重组时无法回退状态
- ❌ **缺少 resubmit**：长期 pending 的交易无法自动重提

#### 幂等与容错层面
- ❌ **无请求 ID 去重**：可能重复消耗 nonce
- ❌ **无"已知交易"处理**：重复提交会报错而非幂等
- ❌ **状态回写无保护**：confirmations 可能被旧节点覆盖

#### 监控与运维层面
- ❌ **无全局视图**：不知道每个 submitter 的 pending 数量
- ❌ **无对账机制**：本地与链上不一致时无法自动修复
- ❌ **无性能指标**：分配耗时、终局延迟等不可见

---

## 二、演进目标与原则

### 2.1 总体目标

将当前"单节点 nonce 分配器"演进为"分布式、高可用、带终局跟踪的完整交易管理系统"。

### 2.2 设计原则

1. **正确性优先**：分布式租约 + fencing 防止竞态
2. **性能兼顾**：路由分片 + 缓存 + 批处理
3. **渐进演进**：每个任务独立可测试、可上线
4. **对齐 FireFly**：复用其核心方法论，但适配我们的架构
5. **保持兼容**：已有 API 继续可用，新能力可选开启

---

## 三、任务拆解（按依赖关系分阶段）

---

## 阶段 1：基础设施增强（分布式协调能力）

### 任务 1.1：实现 Signer 租约表与管理器

**目标**：建立"同一时刻只有一个节点拥有该 signer 执行权"的机制

**详细内容**：

1. 新增数据库表 `signer_lease`

```sql
CREATE TABLE signer_lease (
    signer VARCHAR(128) PRIMARY KEY,
    owner_node VARCHAR(256) NOT NULL,         -- 当前持有者节点 ID
    fencing_token BIGINT NOT NULL,            -- 单调递增的隔离令牌
    acquired_at TIMESTAMP NOT NULL,           -- 获取时间
    expires_at TIMESTAMP NOT NULL,            -- 过期时间
    updated_at TIMESTAMP NOT NULL,
    INDEX idx_expires_at (expires_at)
);
```

2. 实现 `SignerLeaseManager` 接口

```java
public interface SignerLeaseManager {
    /**
     * 尝试获取或续租 lease
     * @return Optional<Lease> 成功则返回 lease（含 fencingToken），失败返回 empty
     */
    Optional<Lease> acquireOrRenew(String signer, String nodeId, Duration leaseDuration);
    
    /**
     * 释放 lease（优雅关闭时调用）
     */
    void release(String signer, long fencingToken);
    
    /**
     * 检查当前节点是否持有有效 lease
     */
    boolean isLeader(String signer, long fencingToken);
}
```

3. 实现 CAS 更新逻辑

```sql
-- 抢占或续租（带 fencing_token 递增）
INSERT INTO signer_lease (signer, owner_node, fencing_token, acquired_at, expires_at, updated_at)
VALUES (:signer, :nodeId, 1, NOW(), :expiresAt, NOW())
ON CONFLICT (signer) DO UPDATE SET
    owner_node = CASE 
        WHEN signer_lease.expires_at < NOW() THEN :nodeId  -- 过期则抢占
        WHEN signer_lease.owner_node = :nodeId THEN :nodeId  -- 续租
        ELSE signer_lease.owner_node  -- 否则保持不变
    END,
    fencing_token = CASE
        WHEN signer_lease.expires_at < NOW() THEN signer_lease.fencing_token + 1
        ELSE signer_lease.fencing_token
    END,
    acquired_at = CASE
        WHEN signer_lease.expires_at < NOW() OR signer_lease.owner_node = :nodeId 
        THEN NOW() ELSE signer_lease.acquired_at
    END,
    expires_at = CASE
        WHEN signer_lease.expires_at < NOW() OR signer_lease.owner_node = :nodeId 
        THEN :expiresAt ELSE signer_lease.expires_at
    END,
    updated_at = NOW()
RETURNING *;
```

**验收标准**：
- [ ] 单元测试：多线程并发抢占，只有一个成功
- [ ] 集成测试：节点 A 持有 lease，节点 B 抢占失败
- [ ] 集成测试：lease 过期后，节点 B 可以抢占且 fencing_token + 1

**影响范围**：新增独立模块，不影响现有功能

**工作量估算**：2-3 天

---

### 任务 1.2：为 Nonce 分配添加 Fencing Token 校验

**目标**：所有写入 nonce allocation 的操作必须带 fencing_token，拒绝旧 token

**详细内容**：

1. `submitter_nonce_allocation` 表增加字段

```sql
ALTER TABLE submitter_nonce_allocation 
ADD COLUMN fencing_token BIGINT DEFAULT 0;

-- 添加复合索引（性能优化）
CREATE INDEX idx_submitter_fencing ON submitter_nonce_allocation(submitter, fencing_token);
```

2. 修改 `NonceService.doAllocate()` 方法

```java
private NonceAllocation doAllocate(String submitter) {
    // 1. 先获取或续租 lease
    Optional<Lease> lease = leaseManager.acquireOrRenew(
        submitter, nodeId, config.getLeaseDuration()
    );
    
    if (!lease.isPresent()) {
        throw new NonceException("无法获取 signer lease: " + submitter);
    }
    
    long fencingToken = lease.get().getFencingToken();
    
    // 2. 在事务内锁定 submitter 状态行
    SubmitterNonceState state = nonceRepository.lockAndLoadState(submitter);
    
    // 3. 回收过期的 RESERVED 状态
    nonceRepository.recycleExpiredReservations(submitter, config.getReservedTimeout());
    
    // 4. 查找可复用的空洞或生成新号
    long targetNonce = findOrGenerateNonce(submitter, state);
    
    // 5. 预留 nonce（带 fencing_token 校验）
    return nonceRepository.reserveNonceWithFencing(
        submitter, targetNonce,
        config.getLockTtl(), fencingToken
    );
}
```

3. 修改 `reserveNonce()` 的 SQL

```sql
INSERT INTO submitter_nonce_allocation 
    (submitter, nonce, status, locked_until, fencing_token, created_at, updated_at)
VALUES 
    (:submitter, :nonce, 'RESERVED', :lockedUntil, :fencingToken, NOW(), NOW())
ON CONFLICT (submitter, nonce) DO UPDATE SET
    status = EXCLUDED.status,
    locked_until = EXCLUDED.locked_until,
    fencing_token = EXCLUDED.fencing_token,
    updated_at = NOW()
WHERE 
    -- 拒绝旧 token 的写入
    submitter_nonce_allocation.fencing_token <= EXCLUDED.fencing_token
    AND submitter_nonce_allocation.status IN ('RESERVED', 'RECYCLABLE');
```

4. 修改 `markUsed()` 和 `markRecyclable()`，也要校验 fencing_token

**验收标准**：
- [ ] 测试：节点 A 持有 token=5，节点 B 持有 token=6，A 的写入被拒绝
- [ ] 测试：lease 过期后旧节点无法继续分配 nonce
- [ ] 测试：状态回写时旧 token 被拒绝（模拟脑裂）

**影响范围**：核心分配逻辑，需要充分测试

**工作量估算**：3-4 天

---

### 任务 1.3：实现基于一致性哈希的路由层（可选）

**目标**：让每个 signer 的请求尽量打到负责的节点（性能优化）

**详细内容**：

1. 网关层实现一致性哈希路由

```java
public class SignerRouter {
    private final ConsistentHash<String> consistentHash;
    
    public String route(String signer) {
        return consistentHash.get(signer);
    }
}
```

2. SDK 层路由逻辑（客户端直连）

```java
// 在业务 SDK 中，根据 signer 路由到目标节点
String targetNode = routingTable.getNode(signer);
nonceClient.allocate(targetNode, signer);
```

**注意**：路由错了也没关系，下一层的 lease 会挡住

**验收标准**：
- [ ] 测试：同一 signer 多次调用路由到同一节点
- [ ] 测试：节点宕机后路由自动切换
- [ ] 压测：路由命中率 > 95%

**影响范围**：新增路由层，不改动核心逻辑

**工作量估算**：2-3 天（可选，性能优化项）

---

## 阶段 2：Nonce 分配增强（对齐链上 + 缓存）

### 任务 2.1：实现链上 Nonce 查询接口

**目标**：能够从区块链查询 signer 的最新 nonce

**详细内容**：

1. 定义 `ChainClient` 接口

```java
public interface ChainClient {
    /**
     * 查询链上该 signer 的下一个可用 nonce
     * @return 链上 next nonce（链上已用最大值 + 1）
     */
    long getNextNonceForSigner(String signer);
    
    /**
     * 查询交易 receipt
     */
    Optional<TransactionReceipt> getReceipt(String txHash);
    
    /**
     * 发送交易到链上
     */
    String sendTransaction(TransactionRequest request);
}
```

2. 实现 Mock/真实 Chain Client（按需）

```java
public class Web3ChainClient implements ChainClient {
    private final Web3j web3j;
    
    @Override
    public long getNextNonceForSigner(String signer) {
        try {
            EthGetTransactionCount count = web3j
                .ethGetTransactionCount(signer, DefaultBlockParameterName.PENDING)
                .send();
            return count.getTransactionCount().longValue();
        } catch (IOException e) {
            throw new ChainException("查询链上 nonce 失败", e);
        }
    }
}
```

**验收标准**：
- [ ] 单元测试：mock 链返回正确 nonce
- [ ] 集成测试：真实链查询成功
- [ ] 异常测试：链超时/报错时返回友好错误

**影响范围**：新增模块，不影响现有功能

**工作量估算**：2 天

---

### 任务 2.2：实现三级决策 max(chain, cache, db)

**目标**：分配 nonce 时综合链上、缓存、DB 三个来源，取最大值

**详细内容**：

1. 新增 `SubmitterNonceCache` 类

```java
public class SubmitterNonceCache {
    private final Cache<String, CachedNonceEntry> cache;
    
    public Optional<CachedNonceEntry> get(String submitter) {
        CachedNonceEntry entry = cache.getIfPresent(submitter);
        if (entry == null) return Optional.empty();
        
        // 检查是否过期
        if (entry.isExpired(config.getNonceStateTimeout())) {
            cache.invalidate(submitter);
            return Optional.empty();
        }
        
        return Optional.of(entry);
    }
    
    public void put(String submitter, long nextNonce) {
        cache.put(submitter, new CachedNonceEntry(nextNonce, Instant.now()));
    }
}
```

2. 修改 `NonceService.findOrGenerateNonce()` 逻辑

```java
private long findOrGenerateNonce(String submitter, SubmitterNonceState state) {
    // 优先复用空洞
    Optional<NonceAllocation> reusable = nonceRepository.findOldestRecyclable(submitter);
    if (reusable.isPresent()) {
        return reusable.get().getNonce();
    }
    
    // 三级决策
    long chainNonce = -1;
    long cacheNonce = -1;
    long dbNonce = state.getNextLocalNonce();
    
    // 1. 查询缓存
    Optional<CachedNonceEntry> cached = nonceCache.get(submitter);
    if (cached.isPresent()) {
        cacheNonce = cached.get().getNextNonce();
    } else {
        // 2. 缓存缺失/过期，查链上
        try {
            chainNonce = chainClient.getNextNonceForSigner(submitter);
        } catch (Exception e) {
            log.warn("查询链上 nonce 失败，使用本地值: {}", submitter, e);
        }
    }
    
    // 3. 取最大值
    long targetNonce = Math.max(Math.max(chainNonce, cacheNonce), dbNonce);
    
    // 4. 更新状态
    state.setNextLocalNonce(targetNonce + 1);
    state.setUpdatedAt(Instant.now());
    nonceRepository.updateState(state);
    
    // 5. 更新缓存
    nonceCache.put(submitter, targetNonce + 1);
    
    return targetNonce;
}
```

3. 批次失败时清理缓存

```java
@Override
public void rollback() {
    // 事务回滚时清理缓存，防止缓存递增但 DB 没提交
    nonceCache.invalidate(submitter);
}
```

**验收标准**：
- [ ] 测试：链上 nonce=10，本地=5，分配时返回 10
- [ ] 测试：缓存有效时不查链（性能优化）
- [ ] 测试：缓存过期时重新查链
- [ ] 测试：批次失败后缓存被清理

**影响范围**：核心分配逻辑，需要充分测试

**工作量估算**：3-4 天

---

### 任务 2.3：实现 Batch Writer 模式（性能优化）

**目标**：将同一 signer 的多个请求批量处理，减少数据库事务次数

**详细内容**：

1. 实现 `NonceBatchWriter`

```java
public class NonceBatchWriter {
    private final Map<String, Queue<AllocationRequest>> queues;
    
    /**
     * 将请求加入队列
     * @return CompletableFuture<NonceAllocation>
     */
    public CompletableFuture<NonceAllocation> enqueue(String submitter, AllocationRequest req) {
        Queue<AllocationRequest> queue = queues.computeIfAbsent(submitter, 
            k -> new ConcurrentLinkedQueue<>()
        );
        
        CompletableFuture<NonceAllocation> future = new CompletableFuture<>();
        req.setFuture(future);
        queue.add(req);
        
        return future;
    }
    
    /**
     * Worker 定期批量处理（每 batchTimeout 或 batchSize 触发）
     */
    @Scheduled(fixedDelay = 50) // 50ms
    public void processBatch() {
        for (Map.Entry<String, Queue<AllocationRequest>> entry : queues.entrySet()) {
            String submitter = entry.getKey();
            Queue<AllocationRequest> queue = entry.getValue();
            
            if (queue.isEmpty()) continue;
            
            List<AllocationRequest> batch = new ArrayList<>();
            for (int i = 0; i < config.getBatchSize() && !queue.isEmpty(); i++) {
                batch.add(queue.poll());
            }
            
            if (!batch.isEmpty()) {
                processBatchForSubmitter(submitter, batch);
            }
        }
    }
    
    private void processBatchForSubmitter(String submitter, List<AllocationRequest> batch) {
        // 在一个事务中处理整个批次
        transactionTemplate.execute(status -> {
            try {
                for (AllocationRequest req : batch) {
                    NonceAllocation allocation = nonceService.doAllocate(submitter, req.getLockOwner());
                    req.getFuture().complete(allocation);
                }
            } catch (Exception e) {
                for (AllocationRequest req : batch) {
                    req.getFuture().completeExceptionally(e);
                }
                status.setRollbackOnly();
            }
            return null;
        });
    }
}
```

**验收标准**：
- [ ] 压测：批处理模式下吞吐量提升 3-5 倍
- [ ] 测试：单个请求失败不影响其他请求
- [ ] 测试：批次超时触发机制正常工作

**影响范围**：新增性能优化模块，可选启用

**工作量估算**：4-5 天

---

## 阶段 3：终局确认系统（Receipt + Confirmations + Reorg）

### 任务 3.1：实现交易记录表（ManagedTransaction）

**目标**：将"交易记录"作为 nonce 的事实载体，而非独立的 allocation 表

**详细内容**：

1. 新增 `managed_transaction` 表

```sql
CREATE TABLE managed_transaction (
    id VARCHAR(64) PRIMARY KEY,               -- 交易 ID（可以用 UUID 或业务单号）
    submitter VARCHAR(128) NOT NULL,
    nonce BIGINT NOT NULL,
    tx_hash VARCHAR(128),                     -- 链上交易哈希
    request_id VARCHAR(128),                  -- 业务请求 ID（幂等）
    status VARCHAR(32) NOT NULL,              -- Pending/Tracking/Confirmed/Failed
    sub_status VARCHAR(32),                   -- Stale/Timeout 等子状态
    first_submit_at TIMESTAMP,                -- 首次提交时间
    last_submit_at TIMESTAMP,                 -- 最近一次提交时间
    confirmed_at TIMESTAMP,                   -- 终局确认时间
    confirmations INT DEFAULT 0,              -- 当前确认数
    receipt_block_number BIGINT,              -- receipt 所在区块号
    receipt_block_hash VARCHAR(128),          -- receipt 所在区块哈希
    error_message TEXT,                       -- 错误信息
    fencing_token BIGINT NOT NULL,            -- 隔离令牌
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    
    UNIQUE(submitter, nonce),
    INDEX idx_submitter_status (submitter, status),
    INDEX idx_tx_hash (tx_hash),
    INDEX idx_request_id (request_id)
);
```

2. 定义状态枚举

```java
public enum TransactionStatus {
    Pending,      // 等待提交
    Tracking,     // 已提交，等待 receipt
    Confirmed,    // 已达到确认阈值
    Failed        // 失败（确定性失败）
}

public enum TransactionSubStatus {
    None,
    Stale,        // 长期无 receipt，触发 resubmit
    Timeout       // 超时
}
```

3. 修改 `NonceExecutionTemplate` 的执行流程

```java
public NonceExecutionResult execute(String submitter, NonceExecutionHandler handler) {
    // 1. 分配 nonce 并创建 ManagedTransaction
    ManagedTransaction tx = txManager.createTransaction(submitter);
    
    try {
        // 2. 执行业务 handler
        NonceExecutionContext ctx = new NonceExecutionContext(
            submitter, tx.getNonce(), tx.getId()
        );
        NonceExecutionResult result = handler.handle(ctx);
        
        // 3. 根据结果更新交易状态
        if (result.getOutcome() == Outcome.SUCCESS) {
            tx.setTxHash(result.getTxHash());
            tx.setStatus(TransactionStatus.Tracking);
            tx.setFirstSubmitAt(Instant.now());
            tx.setLastSubmitAt(Instant.now());
            txRepository.update(tx);
            
            // 4. 将交易加入终局跟踪队列
            confirmationManager.addPendingTransaction(tx);
        } else if (result.getOutcome() == Outcome.NON_RETRYABLE_FAILURE) {
            tx.setStatus(TransactionStatus.Failed);
            tx.setErrorMessage(result.getReason());
            txRepository.update(tx);
        }
        
        return result;
        
    } catch (Exception ex) {
        tx.setStatus(TransactionStatus.Failed);
        tx.setErrorMessage(ex.getMessage());
        txRepository.update(tx);
        throw new NonceException("handler 执行异常", ex);
    }
}
```

**验收标准**：
- [ ] 测试：创建交易记录时自动绑定 nonce
- [ ] 测试：状态流转符合预期（Pending → Tracking → Confirmed）
- [ ] 测试：request_id 去重生效

**影响范围**：架构重构，需要兼容现有 API

**工作量估算**：5-7 天

---

### 任务 3.2：实现 Receipt Checker（异步拉取）

**目标**：异步查询交易的 receipt，不阻塞主路径

**详细内容**：

1. 实现 `ReceiptChecker` 类

```java
public class ReceiptChecker {
    private final LinkedList<PendingItem> queue = new LinkedList<>();
    private final ChainClient chainClient;
    
    /**
     * 添加待检查的交易
     */
    public void addPendingTransaction(ManagedTransaction tx) {
        synchronized (queue) {
            queue.add(new PendingItem(tx.getTxHash(), tx.getId()));
        }
    }
    
    /**
     * Worker 线程：循环处理队列
     */
    public void worker() {
        while (running) {
            PendingItem item;
            synchronized (queue) {
                if (queue.isEmpty()) {
                    Thread.sleep(100);
                    continue;
                }
                item = queue.removeFirst();
            }
            
            try {
                Optional<TransactionReceipt> receipt = chainClient.getReceipt(item.getTxHash());
                
                if (receipt.isPresent()) {
                    // 找到 receipt，通知确认管理器
                    confirmationManager.dispatchReceipt(item.getTxId(), receipt.get());
                } else {
                    // NotFound：更新时间戳，放回队尾
                    item.setLastReceiptCheck(Instant.now());
                    synchronized (queue) {
                        queue.addLast(item);
                    }
                }
                
            } catch (ChainException e) {
                // 非 NotFound 错误：放回队尾并触发退避
                log.warn("查询 receipt 失败: {}", item.getTxHash(), e);
                item.incrementRetryCount();
                
                synchronized (queue) {
                    queue.addLast(item);
                }
                
                // 退避等待（避免紧密重试）
                Thread.sleep(Math.min(1000 * item.getRetryCount(), 30000));
            }
        }
    }
}
```

2. 启动多个 worker 线程

```java
@PostConstruct
public void start() {
    for (int i = 0; i < config.getReceiptWorkers(); i++) {
        executorService.submit(() -> worker());
    }
}
```

**验收标准**：
- [ ] 测试：receipt 查不到时不阻塞其他交易
- [ ] 测试：链错误时触发退避重试
- [ ] 测试：多 worker 并发处理队列

**影响范围**：新增模块，不影响现有功能

**工作量估算**：3-4 天

---

### 任务 3.3：实现确认数管理器（Confirmations）

**目标**：从 receipt 开始沿链回溯，计算确认数并判断终局

**详细内容**：

1. 新增 `confirmations` 表（记录确认链）

```sql
CREATE TABLE transaction_confirmations (
    tx_id VARCHAR(64) NOT NULL,
    block_number BIGINT NOT NULL,
    block_hash VARCHAR(128) NOT NULL,
    parent_hash VARCHAR(128) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    
    PRIMARY KEY (tx_id, block_number),
    INDEX idx_tx_id (tx_id)
);
```

2. 实现 `BlockConfirmationManager`

```java
public class BlockConfirmationManager {
    
    /**
     * 收到 receipt 后，记录起点并开始计算确认数
     */
    public void dispatchReceipt(String txId, TransactionReceipt receipt) {
        ManagedTransaction tx = txRepository.findById(txId);
        
        // 记录 receipt 所在区块
        tx.setReceiptBlockNumber(receipt.getBlockNumber());
        tx.setReceiptBlockHash(receipt.getBlockHash());
        txRepository.update(tx);
        
        // 开始沿链回溯
        walkChainForTransaction(tx);
    }
    
    /**
     * 沿链回溯，计算确认数
     */
    private void walkChainForTransaction(ManagedTransaction tx) {
        long startBlock = tx.getReceiptBlockNumber();
        String startHash = tx.getReceiptBlockHash();
        
        List<BlockInfo> confirmations = new ArrayList<>();
        confirmations.add(new BlockInfo(startBlock, startHash, null));
        
        // 从 startBlock + 1 开始向后查询
        for (long i = startBlock + 1; i <= startBlock + config.getRequiredConfirmations(); i++) {
            Optional<BlockInfo> block = chainClient.getBlockByNumber(i);
            
            if (!block.isPresent()) {
                // 链头未到，退出
                break;
            }
            
            BlockInfo current = block.get();
            BlockInfo previous = confirmations.get(confirmations.size() - 1);
            
            // 检查 parentHash 是否匹配
            if (!current.getParentHash().equals(previous.getHash())) {
                // 检测到重组！标记 newFork=true，清空旧确认链
                log.warn("检测到重组: tx={}, block={}", tx.getId(), i);
                handleReorg(tx, confirmations, current);
                return;
            }
            
            confirmations.add(current);
        }
        
        // 保存确认链
        saveConfirmations(tx.getId(), confirmations, false);
        
        // 判断是否达到终局
        if (confirmations.size() >= config.getRequiredConfirmations()) {
            tx.setStatus(TransactionStatus.Confirmed);
            tx.setConfirmations(confirmations.size());
            tx.setConfirmedAt(Instant.now());
            txRepository.update(tx);
            
            log.info("交易终局确认: tx={}, confirmations={}", tx.getId(), confirmations.size());
        }
    }
    
    /**
     * 处理重组：清空旧确认链，用新分叉重新计算
     */
    private void handleReorg(ManagedTransaction tx, List<BlockInfo> oldConfirmations, BlockInfo newFork) {
        // 删除旧确认记录
        confirmationRepository.deleteByTxId(tx.getId());
        
        // 重新从 receipt 所在块开始验证（可能该块也被重组掉了）
        walkChainForTransaction(tx);
    }
    
    /**
     * 保存确认链（带 newFork 标记）
     */
    private void saveConfirmations(String txId, List<BlockInfo> confirmations, boolean newFork) {
        if (newFork) {
            // 全量覆盖
            confirmationRepository.deleteByTxId(txId);
        }
        
        for (BlockInfo block : confirmations) {
            confirmationRepository.insert(txId, block);
        }
    }
}
```

**验收标准**：
- [ ] 测试：正常情况下确认数递增
- [ ] 测试：检测到重组时清空旧确认链
- [ ] 测试：达到 N 次确认后标记终局
- [ ] 测试：newFork=true 时全量覆盖确认链

**影响范围**：新增核心模块

**工作量估算**：5-7 天

---

### 任务 3.4：实现 Confirmed Block Listener（稳定区块流）

**目标**：只输出达到确认阈值的稳定区块流，避免重组影响下游

**详细内容**：

1. 实现 `ConfirmedBlockListener`

```java
public class ConfirmedBlockListener {
    private final Deque<BlockInfo> window = new ArrayDeque<>();
    private final int requiredConfirmations;
    
    /**
     * 新块到达
     */
    public void onNewBlock(BlockInfo block) {
        // 检查是否与窗口尾部连续
        if (!window.isEmpty()) {
            BlockInfo last = window.getLast();
            
            if (!block.getParentHash().equals(last.getHash())) {
                // 检测到重组：裁剪窗口
                handleReorg(block);
            }
        }
        
        // 加入窗口尾部
        window.addLast(block);
        
        // 如果窗口长度 > requiredConfirmations，输出头部块
        while (window.size() > requiredConfirmations) {
            BlockInfo stable = window.removeFirst();
            dispatchStableBlock(stable);
        }
    }
    
    /**
     * 处理重组：找到分叉点，裁剪后续块
     */
    private void handleReorg(BlockInfo newBlock) {
        // 从后往前找到分叉点
        while (!window.isEmpty()) {
            BlockInfo last = window.getLast();
            
            if (newBlock.getParentHash().equals(last.getHash())) {
                // 找到分叉点，停止裁剪
                break;
            }
            
            window.removeLast();
        }
        
        log.warn("重组裁剪窗口: 剩余块数={}", window.size());
    }
    
    /**
     * 输出稳定块给下游
     */
    private void dispatchStableBlock(BlockInfo block) {
        for (Listener listener : listeners) {
            listener.onStableBlock(block);
        }
    }
}
```

**验收标准**：
- [ ] 测试：窗口外的块被下发
- [ ] 测试：重组时窗口正确裁剪
- [ ] 测试：输出的区块序列单调递增

**影响范围**：新增模块

**工作量估算**：3-4 天

---

### 任务 3.5：实现 BufferChannel（避免下游阻塞）

**目标**：隔离慢消费者，防止一个阻塞导致全局停摆

**详细内容**：

1. 实现 `BufferChannel`

```java
public class BufferChannel {
    private final BlockingQueue<BlockEvent> queue;
    private final int capacity;
    
    /**
     * 尝试发送块事件（非阻塞）
     */
    public boolean tryOffer(BlockEvent event) {
        boolean success = queue.offer(event);
        
        if (!success) {
            // 队列满，设置 GapPotential 标记
            log.warn("下游队列已满，可能漏块: listener={}", listenerName);
            event.setGapPotential(true);
            
            // 丢弃旧事件，强制加入新事件（保证链头不掉队）
            queue.poll();
            queue.offer(event);
        }
        
        return success;
    }
    
    /**
     * 消费端：检测到 GapPotential 后进入补偿逻辑
     */
    public BlockEvent take() throws InterruptedException {
        BlockEvent event = queue.take();
        
        if (event.isGapPotential()) {
            log.warn("检测到可能漏块，触发补偿扫描");
            compensateGap();
        }
        
        return event;
    }
    
    private void compensateGap() {
        // 从链上按块号重扫，填补缺口
        // 具体实现略
    }
}
```

**验收标准**：
- [ ] 测试：队列满时设置 GapPotential
- [ ] 测试：慢消费者不影响其他消费者
- [ ] 测试：补偿逻辑正确触发

**影响范围**：新增模块

**工作量估算**：2-3 天

---

## 阶段 4：交易生命周期管理（Resubmit + 超时）

### 任务 4.1：实现 Policy Loop（交易状态巡检）

**目标**：定期扫描 Tracking 状态的交易，触发 resubmit 或超时判定

**详细内容**：

1. 实现 `PolicyLoop` 定时任务

```java
@Scheduled(fixedDelay = 10000) // 每 10 秒
public void scanTransactions() {
    // 查询所有 Tracking 状态的交易
    List<ManagedTransaction> pendingTxs = txRepository.findByStatus(TransactionStatus.Tracking);
    
    for (ManagedTransaction tx : pendingTxs) {
        processTransaction(tx);
    }
}

private void processTransaction(ManagedTransaction tx) {
    Instant now = Instant.now();
    Duration pendingTime = Duration.between(tx.getLastSubmitAt(), now);
    
    // 判断是否需要 resubmit
    if (pendingTime.compareTo(config.getResubmitInterval()) > 0) {
        resubmitTransaction(tx);
    }
    
    // 判断是否超时（可选）
    if (pendingTime.compareTo(config.getTransactionTimeout()) > 0) {
        handleTimeout(tx);
    }
}

private void resubmitTransaction(ManagedTransaction tx) {
    try {
        // 重新提交同一笔交易（同 nonce）
        String newTxHash = chainClient.sendTransaction(
            TransactionRequest.builder()
                .from(tx.getSubmitter())
                .nonce(tx.getNonce())
                .data(tx.getData())
                .build()
        );
        
        // 更新记录
        tx.setLastSubmitAt(Instant.now());
        tx.setSubStatus(TransactionSubStatus.Stale);
        txRepository.update(tx);
        
        log.info("重提交交易: tx={}, nonce={}, newTxHash={}", 
            tx.getId(), tx.getNonce(), newTxHash);
        
    } catch (ChainException e) {
        log.error("重提交失败: tx={}", tx.getId(), e);
    }
}

private void handleTimeout(ManagedTransaction tx) {
    // 超时处理策略（可配置）
    if (config.isFailOnTimeout()) {
        tx.setStatus(TransactionStatus.Failed);
        tx.setSubStatus(TransactionSubStatus.Timeout);
        tx.setErrorMessage("交易超时未确认");
        txRepository.update(tx);
        
        log.warn("交易超时，标记失败: tx={}, nonce={}", tx.getId(), tx.getNonce());
    } else {
        // 继续重提（FireFly 策略）
        resubmitTransaction(tx);
    }
}
```

**验收标准**：
- [ ] 测试：超过 resubmitInterval 后自动重提
- [ ] 测试：重提交时记录 SubStatus=Stale
- [ ] 测试：超时后按策略标记失败或继续重提

**影响范围**：新增核心功能

**工作量估算**：3-4 天

---

### 任务 4.2：实现 Gas Bump 钩子（可选）

**目标**：允许业务方在 resubmit 时逐步提高 gas，加速交易确认

**详细内容**：

1. 定义 `GasBumpStrategy` 接口

```java
public interface GasBumpStrategy {
    /**
     * 计算新的 gas price
     * @param originalGasPrice 原始 gas price
     * @param resubmitCount 重提次数
     * @return 新的 gas price
     */
    BigInteger calculateNewGasPrice(BigInteger originalGasPrice, int resubmitCount);
}
```

2. 默认实现：线性增长

```java
public class LinearGasBumpStrategy implements GasBumpStrategy {
    @Override
    public BigInteger calculateNewGasPrice(BigInteger originalGasPrice, int resubmitCount) {
        // 每次增加 10%
        BigInteger increment = originalGasPrice.multiply(BigInteger.valueOf(10))
            .divide(BigInteger.valueOf(100));
        return originalGasPrice.add(increment.multiply(BigInteger.valueOf(resubmitCount)));
    }
}
```

3. 在 `resubmitTransaction()` 中调用钩子

```java
private void resubmitTransaction(ManagedTransaction tx) {
    // 计算新 gas price
    BigInteger newGasPrice = gasBumpStrategy.calculateNewGasPrice(
        tx.getOriginalGasPrice(), 
        tx.getResubmitCount()
    );
    
    // 重新提交
    String newTxHash = chainClient.sendTransaction(
        TransactionRequest.builder()
            .from(tx.getSubmitter())
            .nonce(tx.getNonce())
            .gasPrice(newGasPrice)
            .data(tx.getData())
            .build()
    );
    
    tx.setResubmitCount(tx.getResubmitCount() + 1);
    tx.setLastSubmitAt(Instant.now());
    txRepository.update(tx);
}
```

**验收标准**：
- [ ] 测试：重提时 gas price 按策略递增
- [ ] 测试：业务可自定义 GasBumpStrategy
- [ ] 测试：gas price 有上限保护

**影响范围**：增强功能，可选启用

**工作量估算**：2-3 天

---

## 阶段 5：幂等性与容错增强

### 任务 5.1：实现 Request ID 去重

**目标**：避免重复请求消耗多个 nonce

**详细内容**：

1. `managed_transaction` 表已有 `request_id` 字段（唯一索引）

2. 在 `TransactionManager` 中增加预检

```java
public ManagedTransaction createTransaction(String submitter, String requestId) {
    // 1. 预检 request_id 是否已存在
    Optional<ManagedTransaction> existing = txRepository.findByRequestId(requestId);
    if (existing.isPresent()) {
        log.info("请求 ID 已存在，返回已有交易: requestId={}", requestId);
        return existing.get(); // 幂等返回
    }
    
    // 2. 获取 lease
    Optional<Lease> lease = leaseManager.acquireOrRenew(submitter, nodeId, leaseDuration);
    if (!lease.isPresent()) {
        throw new NonceException("无法获取 signer lease: " + submitter);
    }
    
    // 3. 分配 nonce
    NonceAllocation allocation = nonceService.allocate(submitter);
    
    // 4. 创建交易记录（带 request_id）
    ManagedTransaction tx = ManagedTransaction.builder()
        .id(UUID.randomUUID().toString())
        .submitter(submitter)
        .nonce(allocation.getNonce())
        .requestId(requestId)
        .status(TransactionStatus.Pending)
        .fencingToken(lease.get().getFencingToken())
        .createdAt(Instant.now())
        .updatedAt(Instant.now())
        .build();
    
    txRepository.insert(tx);
    return tx;
}
```

**验收标准**：
- [ ] 测试：相同 request_id 多次调用，只分配一次 nonce
- [ ] 测试：并发调用时通过唯一索引保证幂等
- [ ] 测试：返回的 tx_hash 一致

**影响范围**：核心功能增强

**工作量估算**：2 天

---

### 任务 5.2：实现提交灰区策略与幂等处理（细化版）

**目标**：把"链上/节点已接收"与"本地成功"解耦，精细处理三种情况，避免误判失败引发的 nonce 回收风暴

**核心问题说明**：

当交易提交到链上节点时，可能遇到以下情况：
1. **成功返回 txHash**：明确成功，进入 Tracking 状态
2. **返回 "known transaction" 或 "nonce too low"**：节点认为交易已存在，但有两种子情况：
   - **情况 A**：本地已有 txHash（重试、超时重发） → **幂等成功**
   - **情况 B**：本地无 txHash（首次提交但网络超时、节点先收到后响应慢） → **灰区**
3. **其他错误**：明确失败（余额不足、revert 等）

**详细内容**：

#### 1. 新增交易状态枚举（支持灰区）

```java
/**
 * 交易状态枚举（扩展版）
 */
public enum TransactionState {
    PENDING("待提交"),
    TRACKING("已提交，跟踪中"),
    CONFIRMED("已终局确认"),
    FAILED("明确失败"),
    
    /**
     * 灰区状态：链端报告"已知交易"但本地无 txHash
     * 
     * 触发条件：
     * - sendTransaction() 返回 KnownTransaction/NonceTooLow
     * - 本地 managed_tx 的 tx_hash 字段为 NULL
     * 
     * 处理策略：
     * 1. 尝试重算 txHash（需要 connector 支持 computeTransactionHash）
     * 2. 如果无法重算，标记为 UNKNOWN_SUBMIT_RESULT 并告警
     * 3. 后台定期扫描，尝试从链上反查（通过 submitter + nonce）
     * 
     * 风险：
     * - 该 nonce 可能已被外部系统消费
     * - 该 nonce 可能在节点 mempool 但尚未上链
     */
    UNKNOWN_SUBMIT_RESULT("提交结果未知（灰区）");
    
    private final String description;
    
    TransactionState(String description) {
        this.description = description;
    }
    
    public String getDescription() {
        return description;
    }
    
    /**
     * 是否为终局状态（不会再变化）
     */
    public boolean isTerminal() {
        return this == CONFIRMED || this == FAILED;
    }
    
    /**
     * 是否需要人工介入
     */
    public boolean requiresManualIntervention() {
        return this == UNKNOWN_SUBMIT_RESULT;
    }
}
```

---

#### 2. 扩展链端异常类型

```java
/**
 * 链端异常基类
 */
public abstract class ChainException extends RuntimeException {
    public ChainException(String message) {
        super(message);
    }
    
    public ChainException(String message, Throwable cause) {
        super(message, cause);
    }
    
    /**
     * 是否为"可能已提交"的异常（需要特殊处理）
     */
    public abstract boolean isPossiblySubmitted();
}

/**
 * 已知交易异常：节点认为交易已存在
 */
public class KnownTransactionException extends ChainException {
    public KnownTransactionException(String message) {
        super(message);
    }
    
    @Override
    public boolean isPossiblySubmitted() {
        return true; // 可能已在链上或 mempool
    }
}

/**
 * Nonce 过低异常：该 nonce 已被消费
 */
public class NonceTooLowException extends ChainException {
    public NonceTooLowException(String message) {
        super(message);
    }
    
    @Override
    public boolean isPossiblySubmitted() {
        return true; // 该 nonce 确定已被消费
    }
}

/**
 * 确定性失败异常：交易必然不会成功
 */
public class SubmissionRejectedExc extends ChainException {
    private final RejectionReason reason;
    
    public SubmissionRejectedExc(String message, RejectionReason reason) {
        super(message);
        this.reason = reason;
    }
    
    @Override
    public boolean isPossiblySubmitted() {
        return false; // 确定未提交
    }
    
    public enum RejectionReason {
        INVALID_INPUT,      // 输入格式错误
        INSUFFICIENT_FUNDS, // 余额不足
        REVERT,             // 合约执行会 revert
        GAS_TOO_LOW,        // gas 设置过低
        INVALID_SIGNATURE   // 签名错误
    }
}

/**
 * 网络/节点临时错误：可能提交成功也可能失败
 */
public class TransientChainException extends ChainException {
    public TransientChainException(String message, Throwable cause) {
        super(message, cause);
    }
    
    @Override
    public boolean isPossiblySubmitted() {
        return true; // 超时/网络错误，状态不确定
    }
}
```

---

#### 3. ChainClient 的细化错误映射

```java
public class Web3ChainClient implements ChainClient {
    private final Web3j web3j;
    
    @Override
    public String sendTransaction(TransactionRequest request) {
        try {
            EthSendTransaction response = web3j.ethSendRawTransaction(
                request.getSignedData()
            ).send();
            
            if (response.hasError()) {
                Error error = response.getError();
                throw mapChainError(error);
            }
            
            String txHash = response.getTransactionHash();
            if (txHash == null || txHash.isEmpty()) {
                throw new ChainException("节点返回空 txHash");
            }
            
            return txHash;
            
        } catch (IOException e) {
            // 网络错误/超时：无法确定是否提交成功
            throw new TransientChainException("网络错误，提交状态未知", e);
        }
    }
    
    /**
     * 映射链端错误到具体异常类型
     */
    private ChainException mapChainError(Error error) {
        String msg = error.getMessage().toLowerCase();
        
        // 1. 已知交易
        if (msg.contains("known transaction") || 
            msg.contains("already known") ||
            msg.contains("tx already exists") ||
            msg.contains("replacement transaction underpriced")) {
            return new KnownTransactionException(error.getMessage());
        }
        
        // 2. Nonce 过低
        if (msg.contains("nonce too low") || 
            msg.contains("invalid nonce")) {
            return new NonceTooLowException(error.getMessage());
        }
        
        // 3. 余额不足
        if (msg.contains("insufficient funds") || 
            msg.contains("balance too low")) {
            return new SubmissionRejectedExc(
                error.getMessage(), 
                SubmissionRejectedExc.RejectionReason.INSUFFICIENT_FUNDS
            );
        }
        
        // 4. Gas 问题
        if (msg.contains("gas too low") || 
            msg.contains("intrinsic gas")) {
            return new SubmissionRejectedExc(
                error.getMessage(), 
                SubmissionRejectedExc.RejectionReason.GAS_TOO_LOW
            );
        }
        
        // 5. Revert
        if (msg.contains("revert") || 
            msg.contains("execution reverted")) {
            return new SubmissionRejectedExc(
                error.getMessage(), 
                SubmissionRejectedExc.RejectionReason.REVERT
            );
        }
        
        // 6. 其他未知错误（保守处理：视为可能已提交）
        log.warn("未识别的链端错误，保守处理为 TransientChainException: {}", msg);
        return new TransientChainException(error.getMessage(), null);
    }
    
    /**
     * 尝试重算交易哈希（需要原始交易参数）
     */
    public String computeTransactionHash(TransactionRequest request) {
        try {
            // 方案 1：如果有原始签名数据，可以直接 hash
            if (request.getSignedData() != null) {
                return Hash.sha3(request.getSignedData());
            }
            
            // 方案 2：如果有完整参数，重新签名并 hash
            // 注意：需要确保签名的确定性（nonce/gas/data 等完全一致）
            RawTransaction rawTx = RawTransaction.createTransaction(
                request.getNonce(),
                request.getGasPrice(),
                request.getGasLimit(),
                request.getTo(),
                request.getValue(),
                request.getData()
            );
            
            byte[] signedMessage = TransactionEncoder.signMessage(rawTx, request.getCredentials());
            return Hash.sha3(Numeric.toHexString(signedMessage));
            
        } catch (Exception e) {
            log.error("重算交易哈希失败: nonce={}", request.getNonce(), e);
            return null;
        }
    }
}
```

---

#### 4. 提交决策树与处理逻辑

```java
/**
 * 交易提交服务（处理提交的完整决策树）
 */
public class TransactionSubmissionService {
    
    private final ChainClient chainClient;
    private final ManagedTransactionRepository txRepository;
    private final NonceMetrics metrics;
    
    /**
     * 提交交易到链上（处理所有情况）
     * 
     * @return SubmissionResult 包含状态和 txHash（如果可确定）
     */
    public SubmissionResult submitTransaction(ManagedTransaction tx, TransactionRequest request) {
        try {
            // 尝试发送交易
            String txHash = chainClient.sendTransaction(request);
            
            // 情况 1：成功返回 txHash → 明确成功
            return handleSuccessfulSubmission(tx, txHash);
            
        } catch (KnownTransactionException | NonceTooLowException e) {
            // 情况 2：节点报告"已知交易" → 需要细分两种子情况
            return handleKnownTransactionError(tx, request, e);
            
        } catch (SubmissionRejectedExc e) {
            // 情况 3：确定性失败 → 交易不会进入链
            return handleSubmissionRejected(tx, e);
            
        } catch (TransientChainException e) {
            // 情况 4：临时错误（网络/超时） → 状态不确定
            return handleTransientError(tx, e);
        }
    }
    
    /**
     * 情况 1：成功提交
     */
    private SubmissionResult handleSuccessfulSubmission(ManagedTransaction tx, String txHash) {
        tx.setTxHash(txHash);
        tx.setState(TransactionState.TRACKING);
        tx.setFirstSubmitAt(Instant.now());
        tx.setLastSubmitAt(Instant.now());
        tx.setUpdatedAt(Instant.now());
        
        txRepository.update(tx);
        metrics.recordSubmitSuccess(tx.getSubmitter());
        
        log.info("交易提交成功: txId={}, nonce={}, txHash={}", 
            tx.getId(), tx.getNonce(), txHash);
        
        return SubmissionResult.success(txHash);
    }
    
    /**
     * 情况 2：已知交易错误 → 细分处理
     */
    private SubmissionResult handleKnownTransactionError(
            ManagedTransaction tx, 
            TransactionRequest request,
            ChainException error) {
        
        // 2.A：本地已有 txHash → 幂等成功
        if (tx.getTxHash() != null && !tx.getTxHash().isEmpty()) {
            log.info("已知交易（幂等）: txId={}, nonce={}, txHash={}", 
                tx.getId(), tx.getNonce(), tx.getTxHash());
            
            metrics.recordSubmitIdempotent(tx.getSubmitter());
            return SubmissionResult.idempotent(tx.getTxHash());
        }
        
        // 2.B：本地无 txHash → 进入灰区
        log.warn("检测到提交灰区: txId={}, nonce={}, error={}", 
            tx.getId(), tx.getNonce(), error.getMessage());
        
        // 尝试重算 txHash
        String recomputedHash = chainClient.computeTransactionHash(request);
        
        if (recomputedHash != null) {
            // 2.B.1：重算成功 → 补齐 txHash，转为 Tracking
            log.info("重算 txHash 成功，离开灰区: txId={}, txHash={}", 
                tx.getId(), recomputedHash);
            
            tx.setTxHash(recomputedHash);
            tx.setState(TransactionState.TRACKING);
            tx.setFirstSubmitAt(Instant.now());
            tx.setLastSubmitAt(Instant.now());
            tx.setUpdatedAt(Instant.now());
            
            txRepository.update(tx);
            metrics.recordGrayZoneResolved(tx.getSubmitter());
            
            return SubmissionResult.resolvedFromGrayZone(recomputedHash);
            
        } else {
            // 2.B.2：重算失败 → 标记为灰区状态，需要后台补偿
            log.error("无法离开灰区: txId={}, nonce={}", tx.getId(), tx.getNonce());
            
            tx.setState(TransactionState.UNKNOWN_SUBMIT_RESULT);
            tx.setErrorReason(String.format(
                "Chain reported known tx but local has no hash. Original error: %s", 
                error.getMessage()
            ));
            tx.setUpdatedAt(Instant.now());
            
            txRepository.update(tx);
            metrics.recordGrayZoneEntered(tx.getSubmitter());
            
            // 告警：需要人工介入或后台补偿
            alertService.sendAlert(
                AlertLevel.WARNING,
                String.format("交易进入灰区状态: txId=%s, submitter=%s, nonce=%d", 
                    tx.getId(), tx.getSubmitter(), tx.getNonce())
            );
            
            return SubmissionResult.grayZone(error.getMessage());
        }
    }
    
    /**
     * 情况 3：确定性失败 → nonce 未消费，可回收
     */
    private SubmissionResult handleSubmissionRejected(
            ManagedTransaction tx, 
            SubmissionRejectedExc error) {
        
        log.warn("交易确定性失败: txId={}, nonce={}, reason={}", 
            tx.getId(), tx.getNonce(), error.getReason());
        
        tx.setState(TransactionState.FAILED);
        tx.setErrorReason(String.format("Rejected: %s - %s", 
            error.getReason(), error.getMessage()));
        tx.setUpdatedAt(Instant.now());
        
        txRepository.update(tx);
        metrics.recordSubmitRejected(tx.getSubmitter(), error.getReason());
        
        // 注意：这里应该回收 nonce（标记为 RECYCLABLE）
        // 但要通过统一的 nonce 管理接口，而非直接操作
        
        return SubmissionResult.rejected(error.getReason(), error.getMessage());
    }
    
    /**
     * 情况 4：临时错误 → 保持 PENDING，等待重试
     */
    private SubmissionResult handleTransientError(
            ManagedTransaction tx, 
            TransientChainException error) {
        
        log.warn("交易提交临时失败: txId={}, nonce={}, error={}", 
            tx.getId(), tx.getNonce(), error.getMessage());
        
        // 保持 PENDING 状态，不修改数据库
        // 由上层重试逻辑决定是否重试
        
        metrics.recordSubmitTransientError(tx.getSubmitter());
        
        return SubmissionResult.transientError(error.getMessage());
    }
}

/**
 * 提交结果封装类
 */
public class SubmissionResult {
    private final ResultType type;
    private final String txHash;
    private final String errorMessage;
    private final SubmissionRejectedExc.RejectionReason rejectionReason;
    
    public enum ResultType {
        SUCCESS,            // 明确成功
        IDEMPOTENT,         // 幂等成功（本地已有 hash）
        RESOLVED_GRAY_ZONE, // 从灰区恢复（重算 hash 成功）
        GRAY_ZONE,          // 进入灰区（需要后台补偿）
        REJECTED,           // 确定性失败
        TRANSIENT_ERROR     // 临时错误（可重试）
    }
    
    // 工厂方法
    public static SubmissionResult success(String txHash) {
        return new SubmissionResult(ResultType.SUCCESS, txHash, null, null);
    }
    
    public static SubmissionResult idempotent(String txHash) {
        return new SubmissionResult(ResultType.IDEMPOTENT, txHash, null, null);
    }
    
    public static SubmissionResult resolvedFromGrayZone(String txHash) {
        return new SubmissionResult(ResultType.RESOLVED_GRAY_ZONE, txHash, null, null);
    }
    
    public static SubmissionResult grayZone(String errorMessage) {
        return new SubmissionResult(ResultType.GRAY_ZONE, null, errorMessage, null);
    }
    
    public static SubmissionResult rejected(
            SubmissionRejectedExc.RejectionReason reason, 
            String errorMessage) {
        return new SubmissionResult(ResultType.REJECTED, null, errorMessage, reason);
    }
    
    public static SubmissionResult transientError(String errorMessage) {
        return new SubmissionResult(ResultType.TRANSIENT_ERROR, null, errorMessage, null);
    }
    
    // Getters
    public boolean isSuccess() {
        return type == ResultType.SUCCESS || 
               type == ResultType.IDEMPOTENT || 
               type == ResultType.RESOLVED_GRAY_ZONE;
    }
    
    public boolean requiresRetry() {
        return type == ResultType.TRANSIENT_ERROR;
    }
    
    public boolean requiresManualIntervention() {
        return type == ResultType.GRAY_ZONE;
    }
}
```

---

#### 5. 灰区补偿机制（后台定期扫描）

```java
/**
 * 灰区交易补偿服务
 * 
 * 职责：
 * 1. 定期扫描 UNKNOWN_SUBMIT_RESULT 状态的交易
 * 2. 尝试从链上反查（通过 submitter + nonce）
 * 3. 如果找到 txHash，更新状态为 TRACKING
 * 4. 如果确认该 nonce 未被使用，标记为 FAILED 并回收
 */
@Component
public class GrayZoneReconciliationService {
    
    private final ManagedTransactionRepository txRepository;
    private final ChainClient chainClient;
    private final NonceService nonceService;
    
    @Scheduled(fixedDelay = 60000) // 每分钟
    public void reconcileGrayZoneTransactions() {
        List<ManagedTransaction> grayZoneTxs = txRepository.findByState(
            TransactionState.UNKNOWN_SUBMIT_RESULT
        );
        
        for (ManagedTransaction tx : grayZoneTxs) {
            try {
                reconcileSingleTransaction(tx);
            } catch (Exception e) {
                log.error("补偿灰区交易失败: txId={}", tx.getId(), e);
            }
        }
    }
    
    private void reconcileSingleTransaction(ManagedTransaction tx) {
        // 1. 从链上查询该 submitter 的当前 nonce
        long chainCurrentNonce = chainClient.getNextNonceForSigner(tx.getSubmitter());
        
        if (chainCurrentNonce > tx.getNonce()) {
            // 2.A：该 nonce 已被消费，尝试找到对应的 txHash
            Optional<String> txHash = findTransactionHashOnChain(
                tx.getSubmitter(), 
                tx.getNonce()
            );
            
            if (txHash.isPresent()) {
                // 找到了 txHash，离开灰区
                log.info("灰区补偿：找到 txHash: txId={}, txHash={}", 
                    tx.getId(), txHash.get());
                
                tx.setTxHash(txHash.get());
                tx.setState(TransactionState.TRACKING);
                tx.setUpdatedAt(Instant.now());
                
                txRepository.update(tx);
                
            } else {
                // 该 nonce 已被消费，但找不到 txHash（可能被外部系统使用）
                log.warn("灰区补偿：nonce 已被外部消费: txId={}, nonce={}", 
                    tx.getId(), tx.getNonce());
                
                tx.setState(TransactionState.FAILED);
                tx.setErrorReason("Nonce consumed by external system during gray zone");
                tx.setUpdatedAt(Instant.now());
                
                txRepository.update(tx);
                
                // 通知 nonce 服务：该 nonce 已被外部使用（触发对账/纠偏）
            }
            
        } else if (chainCurrentNonce == tx.getNonce()) {
            // 2.B：该 nonce 尚未被消费
            Instant grayZoneEnterTime = tx.getUpdatedAt();
            Duration inGrayZone = Duration.between(grayZoneEnterTime, Instant.now());
            
            if (inGrayZone.compareTo(config.getGrayZoneTimeout()) > 0) {
                // 超时：认为该交易未成功提交，标记失败并回收 nonce
                log.warn("灰区超时，标记失败: txId={}, nonce={}, duration={}", 
                    tx.getId(), tx.getNonce(), inGrayZone);
                
                tx.setState(TransactionState.FAILED);
                tx.setErrorReason("Gray zone timeout: transaction likely not submitted");
                tx.setUpdatedAt(Instant.now());
                
                txRepository.update(tx);
                
                // 回收 nonce
                nonceService.markRecyclable(tx.getSubmitter(), tx.getNonce(), 
                    "Gray zone timeout");
            } else {
                // 还在等待期内，继续观察
                log.debug("灰区交易等待中: txId={}, nonce={}, duration={}", 
                    tx.getId(), tx.getNonce(), inGrayZone);
            }
        }
    }
    
    /**
     * 从链上查找指定 submitter 和 nonce 的交易哈希
     * 
     * 注意：这需要区块链节点支持按 (from, nonce) 查询交易
     * 如果不支持，只能遍历最近的块（性能差）
     */
    private Optional<String> findTransactionHashOnChain(String submitter, long nonce) {
        try {
            // 方案 1（理想）：节点支持 eth_getTransactionByAccountAndNonce
            // return chainClient.getTransactionByAccountAndNonce(submitter, nonce);
            
            // 方案 2（fallback）：遍历最近 N 个块查找
            long currentBlock = chainClient.getLatestBlockNumber();
            int lookbackBlocks = config.getGrayZoneLookbackBlocks(); // 例如 100
            
            for (long i = currentBlock; i > currentBlock - lookbackBlocks && i >= 0; i--) {
                List<Transaction> txs = chainClient.getTransactionsInBlock(i);
                
                for (Transaction tx : txs) {
                    if (tx.getFrom().equalsIgnoreCase(submitter) && 
                        tx.getNonce().longValue() == nonce) {
                        return Optional.of(tx.getHash());
                    }
                }
            }
            
            return Optional.empty();
            
        } catch (Exception e) {
            log.error("从链上查找交易失败: submitter={}, nonce={}", submitter, nonce, e);
            return Optional.empty();
        }
    }
}
```

---

#### 6. 配置项说明

```yaml
nonce:
  submission:
    # 灰区超时时间（超过此时间认为交易未成功提交）
    gray-zone-timeout: 5m
    
    # 灰区反查回溯区块数（性能 vs 准确性权衡）
    gray-zone-lookback-blocks: 100
    
    # 是否启用自动补偿
    gray-zone-reconciliation-enabled: true
    
    # 补偿扫描间隔
    gray-zone-reconciliation-interval: 60s
    
  # 链端能力配置
  chain:
    # 是否支持重算 txHash（需要保存完整交易参数）
    support-hash-recomputation: true
    
    # 是否支持按 (from, nonce) 查询交易
    support-query-by-nonce: false
```

---

**验收标准**：

**基础功能**：
- [ ] 测试：成功提交返回 txHash，状态变为 TRACKING
- [ ] 测试：重复提交（本地有 hash）幂等返回成功，不重复占号
- [ ] 测试：KnownTransaction 且本地无 hash，能重算 hash 并离开灰区
- [ ] 测试：KnownTransaction 且无法重算 hash，进入 UNKNOWN_SUBMIT_RESULT 状态

**灰区补偿**：
- [ ] 测试：灰区交易在补偿周期内被找到 txHash，状态更新为 TRACKING
- [ ] 测试：灰区交易超时后标记为 FAILED，nonce 被回收
- [ ] 测试：灰区交易的 nonce 被外部消费，状态更新为 FAILED

**异常场景**：
- [ ] 测试：网络超时（TransientChainException）保持 PENDING，不改状态
- [ ] 测试：确定性失败（余额不足）标记为 FAILED，nonce 可回收
- [ ] 测试：NonceTooLow 且本地有 hash，幂等成功

**监控告警**：
- [ ] 测试：进入灰区时触发告警
- [ ] 测试：灰区超时时触发告警
- [ ] 测试：Prometheus 指标正确记录（成功/幂等/灰区/失败计数）

**影响范围**：核心功能增强，涉及交易提交、状态管理、补偿机制

**工作量估算**：4-5 天

**风险与回滚**：
- 风险：灰区判定逻辑复杂，可能误判
- 缓解：充分的单元测试 + 集成测试，灰度发布时重点观察灰区交易比例
- 回滚：如果灰区交易过多，可以临时关闭补偿机制，改为人工介入

---

### 任务 5.3：实现状态回写的 Fencing 校验

**目标**：防止旧节点覆盖新节点的 confirmations 写入

**详细内容**：

1. 在 `saveConfirmations()` 时校验 fencing_token

```java
private void saveConfirmations(String txId, List<BlockInfo> confirmations, boolean newFork) {
    ManagedTransaction tx = txRepository.findById(txId);
    
    // 检查当前节点是否持有有效 lease
    if (!leaseManager.isLeader(tx.getSubmitter(), tx.getFencingToken())) {
        log.warn("无效 lease，拒绝写入 confirmations: txId={}, token={}", 
            txId, tx.getFencingToken());
        return;
    }
    
    if (newFork) {
        confirmationRepository.deleteByTxId(txId);
    }
    
    for (BlockInfo block : confirmations) {
        confirmationRepository.insert(txId, block);
    }
}
```

2. 在 `updateTransactionStatus()` 时也要校验

```java
public void updateTransactionStatus(String txId, TransactionStatus newStatus) {
    ManagedTransaction tx = txRepository.findById(txId);
    
    // 校验 fencing token
    if (!leaseManager.isLeader(tx.getSubmitter(), tx.getFencingToken())) {
        throw new NonceException("无效 lease，拒绝更新状态");
    }
    
    tx.setStatus(newStatus);
    tx.setUpdatedAt(Instant.now());
    txRepository.update(tx);
}
```

**验收标准**：
- [ ] 测试：旧 token 的写入被拒绝
- [ ] 测试：脑裂时旧节点无法覆盖新节点
- [ ] 测试：lease 过期后写入失败

**影响范围**：核心功能增强

**工作量估算**：2 天

---

## 阶段 6：监控与运维能力

### 任务 6.1：实现全局监控视图

**目标**：实时查看每个 signer 的 nonce 使用情况

**详细内容**：

1. 新增 HTTP API

```java
@GetMapping("/api/nonce/status/{submitter}")
public NonceStatusResponse getStatus(@PathVariable String submitter) {
    return NonceStatusResponse.builder()
        .submitter(submitter)
        .nextLocalNonce(stateRepository.getNextLocalNonce(submitter))
        .pendingCount(txRepository.countByStatus(submitter, TransactionStatus.Tracking))
        .confirmedCount(txRepository.countByStatus(submitter, TransactionStatus.Confirmed))
        .failedCount(txRepository.countByStatus(submitter, TransactionStatus.Failed))
        .recyclableCount(allocationRepository.countByStatus(submitter, NonceAllocationStatus.RECYCLABLE))
        .build();
}
```

2. 新增 Prometheus 指标

```java
@Component
public class NonceMetrics {
    private final Counter nonceAllocatedCounter;
    private final Counter nonceUsedCounter;
    private final Counter nonceRecycledCounter;
    private final Gauge pendingTransactionsGauge;
    
    public void recordAllocate(String submitter) {
        nonceAllocatedCounter.labels(submitter).inc();
    }
    
    public void recordUsed(String submitter) {
        nonceUsedCounter.labels(submitter).inc();
    }
    
    public void updatePendingCount(String submitter, int count) {
        pendingTransactionsGauge.labels(submitter).set(count);
    }
}
```

**验收标准**：
- [ ] API 返回正确的统计数据
- [ ] Prometheus 指标可被采集
- [ ] Grafana 面板展示关键指标

**影响范围**：新增运维功能

**工作量估算**：2-3 天

---

### 任务 6.2：实现链上对账与自动修复

**目标**：检测本地与链上不一致，自动触发对账

**详细内容**：

1. 实现 `NonceReconciliationService`

```java
@Scheduled(fixedDelay = 300000) // 每 5 分钟
public void reconcileAll() {
    List<String> submitters = stateRepository.getAllSubmitters();
    
    for (String submitter : submitters) {
        try {
            reconcileSubmitter(submitter);
        } catch (Exception e) {
            log.error("对账失败: submitter={}", submitter, e);
        }
    }
}

public void reconcileSubmitter(String submitter) {
    // 1. 查询链上最新 nonce
    long chainNonce = chainClient.getNextNonceForSigner(submitter);
    
    // 2. 查询本地 next_local_nonce（本地分配游标/水位）
    SubmitterNonceState state = stateRepository.findBySubmitter(submitter);
    long localNext = state.getNextLocalNonce();
    
    // 3. 对比差异
    if (chainNonce > localNext) {
        log.warn("检测到 nonce 漂移: submitter={}, localNext={}, chainNext={}", 
            submitter, localNext, chainNonce);
        
        // 4. 触发修复
        alignWithChain(submitter, chainNonce);
    }
}

private void alignWithChain(String submitter, long chainNonce) {
    transactionTemplate.execute(status -> {
        // 1. 更新 state
        SubmitterNonceState state = stateRepository.findBySubmitter(submitter);
        state.setLastChainNonce(chainNonce - 1);
        state.setNextLocalNonce(chainNonce);
        stateRepository.update(state);
        
        // 2. 标记 <= chainNonce 的交易为 USED
        int updated = txRepository.markUsedByNonceRange(submitter, 0, chainNonce - 1);
        log.info("对账完成: submitter={}, updated={}", submitter, updated);
        
        return null;
    });
}
```

**验收标准**：
- [ ] 测试：检测到漂移时自动对账
- [ ] 测试：对账后本地与链上一致
- [ ] 测试：对账不影响正在 pending 的交易

**影响范围**：新增核心功能

**工作量估算**：3-4 天

---

### 任务 6.3：实现告警机制

**目标**：关键异常时触发告警

**详细内容**：

1. 定义告警接口

```java
public interface AlertService {
    void sendAlert(AlertLevel level, String message);
}
```

2. 在关键路径埋点

```java
// Redis 降级
if (redisDown) {
    alertService.sendAlert(AlertLevel.WARNING, "Redis 不可用，已降级到纯 DB 模式");
}

// RESERVED 堆积
int reservedCount = allocationRepository.countByStatus(submitter, NonceAllocationStatus.RESERVED);
if (reservedCount > config.getReservedThreshold()) {
    alertService.sendAlert(AlertLevel.ERROR, 
        String.format("RESERVED 堆积超阈值: submitter=%s, count=%d", submitter, reservedCount)
    );
}

// 对账失败
if (!reconcileSuccess) {
    alertService.sendAlert(AlertLevel.CRITICAL, 
        String.format("对账失败: submitter=%s", submitter)
    );
}
```

**验收标准**：
- [ ] 测试：告警正确触发
- [ ] 集成：对接钉钉/邮件/短信
- [ ] 配置：告警阈值可调整

**影响范围**：新增运维功能

**工作量估算**：2 天

---

## 四、实施策略与优先级

### 4.1 优先级划分

#### P0（必须）：分布式协调 + 终局跟踪核心
- 任务 1.1：Signer 租约表与管理器
- 任务 1.2：Fencing Token 校验
- 任务 2.1：链上 Nonce 查询接口
- 任务 2.2：三级决策 max(chain, cache, db)
- 任务 3.1：ManagedTransaction 表
- 任务 3.2：Receipt Checker
- 任务 3.3：确认数管理器
- 任务 4.1：Policy Loop（resubmit）
- 任务 5.1：Request ID 去重
- 任务 5.3：状态回写 Fencing 校验

#### P1（重要）：性能优化 + 幂等增强
- 任务 1.3：一致性哈希路由（可选）
- 任务 2.3：Batch Writer 模式
- 任务 3.4：Confirmed Block Listener
- 任务 5.2："已知交易"错误处理

#### P2（次要）：监控运维
- 任务 3.5：BufferChannel
- 任务 4.2：Gas Bump 钩子
- 任务 6.1：全局监控视图
- 任务 6.2：链上对账
- 任务 6.3：告警机制

### 4.2 实施顺序建议

#### 第一轮迭代（2-3 周）：分布式协调基础
1. 任务 1.1 → 1.2：建立租约机制
2. 任务 2.1 → 2.2：对齐链上 nonce
3. 任务 5.1：幂等去重

**交付物**：能够在多节点环境下安全分配 nonce，防止脑裂

#### 第二轮迭代（3-4 周）：终局跟踪系统
1. 任务 3.1：交易记录表改造
2. 任务 3.2 → 3.3：Receipt + Confirmations
3. 任务 4.1：Resubmit 机制
4. 任务 5.3：状态回写保护

**交付物**：完整的交易生命周期管理，从分配到终局全链路可见

#### 第三轮迭代（1-2 周）：性能优化
1. 任务 2.3：批处理模式
2. 任务 3.4：稳定区块流
3. 任务 5.2：幂等增强
4. 任务 1.3：路由优化（可选）

**交付物**：吞吐量提升 3-5 倍，延迟降低

#### 第四轮迭代（1-2 周）：监控运维
1. 任务 6.1 → 6.2 → 6.3：监控、对账、告警
2. 任务 3.5、4.2：其他增强功能

**交付物**：完善的运维体系，可观测、可运维

### 4.3 风险控制

#### 兼容性风险
- **策略**：保留现有 `NonceService` API，新功能通过配置开关启用
- **降级方案**：关键功能支持降级（如 lease 失败时可回退到 Redis 锁）

#### 性能风险
- **策略**：分阶段上线，每个阶段都做压测
- **基准**：确保每个阶段的性能不低于上一阶段

#### 数据一致性风险
- **策略**：充分的单元测试 + 集成测试 + 混沌测试
- **验证**：每个任务都要有"竞态场景"的测试用例

---

## 五、配置项设计

```yaml
nonce:
  # 分布式租约
  lease:
    enabled: true                      # 是否启用租约机制
    duration: 30s                      # 租约时长
    renew-interval: 10s                # 续租间隔
    
  # Nonce 分配
  allocation:
    nonce-state-timeout: 5m            # nonce 状态过期时间
    reserved-timeout: 10m              # RESERVED 超时时间
    batch-size: 10                     # 批处理大小
    batch-timeout: 50ms                # 批处理超时
    
  # 终局确认
  confirmations:
    required: 20                       # 终局确认数
    stale-receipt-timeout: 60s         # receipt 兜底查询周期
    fetch-receipt-upon-entry: false    # 入队时立即查 receipt
    receipt-workers: 10                # receipt 查询 worker 数
    block-queue-length: 1000           # 区块队列长度
    
  # Resubmit
  resubmit:
    interval: 5m                       # resubmit 间隔
    max-attempts: 10                   # 最大重提次数
    gas-bump-enabled: false            # 是否启用 gas bump
    
  # 超时
  timeout:
    transaction-timeout: 30m           # 交易总超时时间
    fail-on-timeout: false             # 超时是否标记失败
    
  # 监控
  monitoring:
    reserved-threshold: 100            # RESERVED 告警阈值
    reconciliation-interval: 5m        # 对账周期
    
  # Redis
  redis:
    enabled: true                      # 是否启用 Redis
    degrade-on-failure: true           # 失败时是否降级
    lock-ttl: 10s                      # 锁 TTL
    
  # 路由（可选）
  routing:
    enabled: false                     # 是否启用路由
    strategy: consistent-hash          # 路由策略
```

---

## 六、测试策略

### 6.1 单元测试覆盖率目标
- 核心逻辑（Lease、Nonce 分配、状态流转）：> 90%
- 边界条件（并发、异常、超时）：> 80%

### 6.2 集成测试场景
- [ ] 多节点并发分配，无冲突
- [ ] 节点宕机后 lease 自动转移
- [ ] 链重组时确认数正确回退
- [ ] resubmit 正常触发
- [ ] 对账修复本地与链上差异

### 6.3 压力测试指标
- 吞吐量：> 1000 TPS（单 signer）
- 延迟：P99 < 500ms（分配 nonce）
- 终局延迟：平均 < 60s（20 次确认）

### 6.4 混沌测试
- 随机杀节点
- 随机网络分区
- 随机 Redis 故障
- 随机链返回错误

---

## 七、文档交付清单

- [ ] 架构设计文档
- [ ] 接口文档（API + 配置）
- [ ] 运维手册（部署、监控、故障处理）
- [ ] 开发者指南（如何接入、最佳实践）
- [ ] 性能调优指南
- [ ] 故障排查手册

---

## 八、总结

本演进计划将当前系统从"单节点 nonce 分配器"升级为"分布式、高可用、带终局跟踪的完整交易管理系统"，核心特点：

1. **正确性**：租约 + fencing 防止脑裂
2. **性能**：路由分片 + 缓存 + 批处理
3. **完整性**：从分配到终局全生命周期管理
4. **可运维**：监控、对账、告警一应俱全

**总工作量估算**：约 8-10 周（2-3 人月）

**建议实施方式**：按优先级分 4 轮迭代，每轮独立可测试、可上线。

