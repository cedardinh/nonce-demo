============================== FireFly ==============================
被设计为一个开源中间件或 Web3 编排引擎，通过将传统系统连接到去中心化网络来简化安全的应用程序开发。该架构由多个可插拔组件组成。FireFly Core 充当中央编排器。
管理简化的 REST API 接口、内部消息排序和整体状态协调。与特定区块链技术的交互通过连接器层进行抽象。

什么是Nonce？
----------------------------------------------------------------------

在区块链（特别是以太坊等EVM兼容链）中，Nonce（Number used ONCE）是一个与特定账户地址关联的序列号，用于：标识从该地址发出的交易的顺序、防止交易重放攻击、确保交易按正确顺序执行

节点返回结果时，可能出现与 nonce 相关的错误：
    Nonce too low（nonce 太低）
        说明该 nonce 已被使用（可能是外部系统或其它原因）。
        FFTM 会检测错误并重新查询链上 nonce，发现冲突后，通常会将本次交易标记为失败/冲突，而不会强行覆盖。
    Nonce too high（nonce 太高 / 中间有缺口）
        说明前面的某个 nonce 对应的交易缺失。
        FFTM 在设计上不会主动“跳号”分配 nonce，因此一般不会出现这种情况，除非之前的交易被人为删除或 DB 出现异常。
        如果出现，节点会将该交易暂时挂起（等待前序 nonce 被填补）。
    其它错误（Gas 不足、交易无效等）
        由 Transaction Handler 策略 决定如何处理（重试 / 标记失败等），见下节。

----------------------------------------------------------------------

nonce 计算逻辑
FFTM 计算下一个 nonce 时，会综合 本地持久化状态 + 区块链节点状态：

- 在自身数据库中缓存/记录某地址已分配的最高 nonce（例如 lastNonce）。
- 正常情况下，下一个 nonce = lastNonce + 1。
- 为避免与 外部系统（或人工）使用同一账户导致冲突，FFTM 还可以通过配置在必要时 向节点查询当前 pending nonce：
  - 调用 eth_getTransactionCount(address, "pending") 等。
  - 若节点返回值更高，则以节点值为基准，确保与链上最新状态对齐。
- 控制“是否查询节点”的核心参数是：transactions.nonceStateTimeout：
  - 如果某地址最近一次交易的时间超过该超时时间，则在分配下一个 nonce 前，强制向节点查询。
  - 若设为 0，则 每笔交易都会查询节点。
  - 在单系统独占账户场景，可以设得稍大；在账户被其他系统共用的情况下，应设小甚至为 0，以尽量减少冲突窗口。

文档中特别强调：最好不要在 FireFly 之外使用相同的签名密钥；若必须如此，则通过缩小超时时间降低风险。

----------------------------------------------------------------------

交易卡住时的重提交
若交易在一定时间内未被打包出块（pending 太久），handler 会 使用相同 nonce 重新提交、提升 gas 价格。
配置项 transactions.handler.simple.resubmitInterval 控制重提周期（例如 30 秒）。
若节点返回 "replacement transaction underpriced"（替代交易 gas 不足以覆盖前一次），handler 继续提升 gas 后再次提交。

重提次数与结束条件
可多次重试，直到：

- 交易被打包，得到回执（成功/失败）
- 达到某种最大重试或超时策略，被标记为最终失败

----------------------------------------------------------------------

子状态状态机
每笔交易维护一个详细的 子状态（sub-status）状态机 + 行为历史（history）

Received（已接收），初始状态：FFTM 收到提交请求。
典型动作：
    AssignNonce（分配 nonce）
    RetrieveGasPrice（获取 gas 价格）
    SubmitTransaction（提交交易）
若提交失败（如网络错误），可能在此状态中重试 SubmitTransaction。

Tracking（Pending）（跟踪中 / 挂起），表示交易已成功提交到链上，拥有 tx hash。
典型动作：
    ReceiveReceipt（轮询回执，可能多次）
    Confirm（达到指定确认数后标记确认）
若发生重提交（替换交易），也会记录相关 SubmitTransaction 动作。

Confirmed（已确认）
交易被链确认并达到设定的区块确认数，状态终止为成功。

Failed（失败）
交易最终失败（例如回执 status=0 或被视为不可恢复地卡住）。

Suspended（挂起）
可通过管理 API 手动暂停该交易的自动处理。

----------------------------------------------------------------------

持久化模型
每笔交易记录包含以下核心字段（概念上）：

- 唯一 ID（可与 FireFly Operation 相关联）
- 签名地址（signer address）
- 分配的 nonce
- tx hash（提交成功后获得）
- 交易内容（合约地址、方法、参数、value、gas 等）
- 状态（Received / Tracking / Confirmed / Failed / Suspended 等）
- 创建时间、最后更新时间
- 可能还有对 FireFly Transaction 或 Operation 的引用

一旦 nonce 分配完成，就会立刻写入该记录。

唯一性约束：
在 SQL 模式下，通常会对（signerAddress, nonce）创建唯一索引，确保同一地址同一 nonce 只能有一条记录。即使逻辑锁意外失效，这种约束也能从数据库层防止重复分配。

历史 & 子状态记录
history：数组形式，包含多个子状态条目：

- 每条记录包括：subStatus、time、actions[]
- actions 包含 type（例如 AssignNonce）、count、lastOccurred、info 等
- historySummary：列出该交易生命周期中所有出现过的子状态和动作类型，用于快速概览。

这些历史用于调试和监控，并不会改变核心逻辑。可以通过配置限制最多保留多少条历史记录（例如 maxHistoryCount）。

----------------------------------------------------------------------

批量写入与性能
采用 flush writer 模式将多条事务写入合并为较少的数据库提交。
多个并发交易提交时，FFTM 会将 insert/update 合并到一个批次中提交，以减少数据库开销。

----------------------------------------------------------------------

与 Core Operation 的协调
FireFly Core 的数据库中存储的是高层次的 Operation 记录：

- 状态（pending、succeeded、failed）
- 少量链相关信息（如最终 tx hash、block number）。

FFTM 则存储链级的详细状态机和 nonce 信息，而 Core 仅持有汇总视图。
FFTM 状态更新时，会通过回调/事件更新 Core 的 Operation。
因此，FFTM 的持久化是 nonce 与交易处理的“真相源”（source of truth），Core 的记录则是供应用查询的简化视图。

----------------------------------------------------------------------

无缺口（No Gaps）保证
由于 FFTM 始终保留 pending 交易记录直到其 Confirmed/Failed，并通过递增 nonce 分配：

- 对于每个地址，数据库中的 nonce 序列是连续的；
- 即便某笔交易卡住，其对应 nonce 记录仍然存在，不会被跳过；
- 只有在交易被确认为“已经消耗了该 nonce”（无论 success/fail）后，才继续分配下一 nonce。

因此，在 FFTM 管控下，不会出现“看不见的 nonce 空洞”。每一个 nonce 都有对应的交易记录。

----------------------------------------------------------------------

崩溃恢复模型

1. 从数据库加载所有 未终结（非 Confirmed/Failed） 的交易。
2. 重新初始化链事件监听（新区块、交易回执等）。
3. 对每一笔 pending 交易，根据其子状态决定下一步：
   - 若状态为“已提交但无回执”：恢复轮询回执。
   - 若已收到回执但等待确认数：继续等待剩余区块。
   - 若尚未提交（极少见）：尝试提交。
4. 确认管理器会在重启后对所有在跟踪中的交易做一次 fetchReceipt 检查。如果这段停机期间节点已经打包了这些交易，将很快收到回执并更新状态。

----------------------------------------------------------------------

重启下的 Exactly-once 行为

1. 分配 nonce 后、尚未发送交易就崩溃
   - DB 中已有该 nonce 交易记录，但没有 tx hash。
   - 重启后，FFTM 检测到该记录仍处于“未提交”状态，可安全地第一次提交。
   - 链上视角看，这是该 nonce 的首次出现，不会有重复。

2. 发送交易后、在记录 tx hash 前崩溃
   - 交易可能已被节点接收（在 mempool 内），但 FFTM 未持久化 tx hash。
   - 重启后，FFTM 看到有已分配 nonce，但无提交确认记录。
   - 处理方式：
     先向节点查询 pending nonce，发现节点 nonce 已高于本地 state。
     这暗示交易可能已发送并进入 mempool，或已被打包。
     FFTM 可选择等待事件流或回执，若迟迟没有结果，则重新用 同样的 nonce 和交易内容 再次提交。
     若之前的交易仍在 mempool 中，重复提交相同内容会被节点视为重复（可能返回 "already known"），对最终结果无害。
     若之前交易丢失，这次就是补发，仍然是“逻辑上的同一笔”。
   - 从应用角度看，仍是 一次逻辑操作，不会产生两笔不同的业务效果。

3. FFTM 停机期间，节点继续出块
   - 某些 pending 交易可能被打包。
   - 重启后，通过回执轮询和事件重放，FFTM 会发现这些交易的 Confirmation 并更新状态。
   - 若存在多次重提交的历史，也会在 history 中体现。

----------------------------------------------------------------------

事件流与 checkpoint
FFTM 与 Core/应用之间的事件流采用 “至少一次”投递语义（at-least-once）：

- 重启或网络抖动可能导致某些“交易已确认”事件被重复发送。
- FireFly Core 内部通过唯一 ID 和 Operation 状态判断是否已处理，从而避免产生重复记录。

FFTM 对事件流使用 checkpoint（检查点）机制：

- 事件只会在确认一定数目的区块后才被视为 final 并写入 checkpoint。
- 对于处在“链头不稳定区”的事件，重启时可能被重放，以防 reorg。

这意味着：即便事件有重复，应用只看到幂等的最终状态。

----------------------------------------------------------------------

处理 reorg（链重组）
FFTM 的确认管理器通过配置 confirmations.required 控制所需确认数。
在达到确认数之前，若遇到链重组，某笔交易所在 block 从主链中被移除：

- FFTM 监测到该交易所在 block 不再在主链中，
- 将交易状态从“已确认临时”退回到“Tracking/Pending”，
- 继续监控其是否在新链上被 re-insert 或最终被替代。
  若最终该交易完全消失（未再次被打包），通常节点会将其重新放回 mempool，FFTM 会继续跟踪或最终标记失败。

由于 FireFly 在多方网络中要求所有节点对事件有一致的视图，它会基于确认和 checkpoint 带来一致的最终顺序。

----------------------------------------------------------------------

链重组过程基于区块链的最长链原则（在 pow 机制中）或类似共识规则。具体步骤如下：

1. 分叉的产生：当两个或多个矿工（或验证者）几乎同时各自挖出一个有效的区块，并将它们广播到网络时，网络中的不同节点会各自收到不同的区块，导致区块链暂时出现分叉（分裂）。
2. 各自延长：不同的节点会基于自己首先收到的区块继续向后挖矿，形成各自独立的区块链分支。
3. 冲突解决（重组）：随着时间的推移，其中一个分支会率先被延长，成为累积工作量最大（或最长）的链。
4. 网络共识：网络中的其他节点会检测到这条更长的链，并放弃自己原先遵循的较短分支。
5. 交易回滚：原本记录在较短分支区块中的交易会被“回滚”到内存池（mempool）中，等待被重新打包进新的主链区块。这就是“重组”发生的核心，用户的交易可能会暂时从主链上消失。

----------------------------------------------------------------------

===================================故障场景与竞争条件===================================
多系统共用同一账户：也就是说另一个系统或用户在 FireFly 之外也用同一账户发送交易 时，会出现典型的 nonce 竞争问题。
若业务确实必须这么做，则建议：把 transactions.nonceStateTimeout 设成很小甚至 0，让 FFTM 每次都从链上拉取当前 nonce。
这样可以显著缩小冲突窗口，但 不能完全消除 风险。

当两边同时在极短时间内提交时，仍可能发生：
    节点先接收外部系统的交易，用掉某个 nonce；
    FFTM 根据旧状态分配了同一个 nonce；
    则 FFTM 提交时会得到 "nonce too low" 错误。

此时 FFTM 会：
    重新向节点查询 nonce，发现该 nonce 已被外部交易占用；
    通常将本事务标记为“nonce 冲突/失败”，而不会试图覆盖；
    或在策略上用下一个 nonce 重试。这取决于业务配置，但一般不推荐自动跳号。

该场景本质是 违反“单一 nonce 源”原则 的结果。FireFly 能提供一定缓解，但无法从根本解决。

----------------------------------------------------------------------

交易执行失败
当某笔交易在 EVM 内部执行时失败（例如 require 失败导致 revert）：

- 该交易仍然会生成回执（receipt），并且 nonce 已被消耗。
- FFTM 会把 Operation 标记为 Failed，并包含回执中的错误信息。
- 后续 nonce 可以继续正常分配（例如从 5 失败后，分配 6、7 等）。

FireFly 的“顺序保证”是指 链上执行顺序 与 提交顺序 一致，而不是“所有事务都成功”。这意味着：

- 若 txn5 revert 而 txn6 成功，则系统报告 txn5 失败、txn6 成功；
- 不会回滚 txn6 或做全局一致性补偿，这需业务逻辑自行处理。

----------------------------------------------------------------------

交易卡住（Gas 太低 / 未被传播）
当交易长期 pending，可能是因为：

- Gas price 太低，矿工不愿打包；
- 网络抖动导致传播不畅。

FFTM 会通过重提交逻辑提升 Gas 尝试解决：

- 若多次重试仍无效，通常由运维介入，或通过 Suspend/Resume API 手动处理：
  - 暂停该交易的自动处理，
  - 人工使用同一 nonce 发出“取消交易”（例如向自己转 0 ETH、较高 Gas），
  - 然后在 FireFly 中将该 transaction 为失败，再允许后续交易继续。

FireFly 不会自动“跳过某个 nonce 而继续发后面的交易”，而是倾向保守：宁可停下来让人手干预，也不隐式违反顺序及一致性假设。

----------------------------------------------------------------------

区块链节点故障/切换
当以太坊节点（RPC）故障或网络不可达时：

- FFCAPi 调用会失败（如 SendTransaction 返回错误）。
- FFTM 不会把交易标记为已完成，而是保留在 Received 或 Pending 状态，并周期性重试。
- nonce 仍然被保留，不会释放给其它交易。
- 节点恢复后，FFTM 会继续提交，保证不会丢失交易。
  事件监听同样会重连：
- 当节点恢复时，连接器重新订阅区块/事件，重放停机期间漏掉的事件。

----------------------------------------------------------------------

并发交易与 maxInFlight
配置项 transactions.handler.simple.maxInFlight 控制每个地址 最多有多少笔“已提交但未确认”的交易可在链上排队：

- 若设置为 1：严格串行，FFTM 等待上一笔确认后才发送下一笔。
- 若大于 1：可以流水线式提交多笔（例如 5 笔），节点会按 nonce 排队执行。

在以太坊上，即使你提交多笔并发交易，它们仍按 nonce 顺序执行：

- 若某个较早 nonce 的交易 A 卡住，后面 nonce 的交易 B、C 也不会被打包，直到 A 被处理（打包或替换）。
  FFTM 的确认管理器会专门关注最早那笔（最小 nonce），通过重提交提升 Gas 尝试推进它。

因此，提高 maxInFlight 能提升吞吐，但对“卡住交易”问题并没有根本解决，而是增加了挂起队列的长度。合理的值要在吞吐与资源可控之间折中。

交易丢掉，然后返回 error
这个值不配置也不会导致严重问题。原因是：
因此，maxInFlight 配置更多是针对应用层面的主动流量管理和性能优化，确保应用本身不会向节点发送无法及时处理的过多交易，从而更好地控制资源和提升吞吐量。

----------------------------------------------------------------------

相关配置：

1. transactions.nonceStateTimeout
   含义：上一次针对某地址分配 nonce 的时间距现在超过该值时，分配下一个 nonce 前要先从链上查询当前 pending nonce。
   典型用法：

   - 0：每笔交易都查询一次链上 nonce（最保守）。
   - 较大值：FFTMs 批量处理时可减少链查询，性能更好。

2. transactions.handler.simple.maxInFlight
   含义：每个地址可同时在链上 pending 的最大交易数。
   调整效果：

   - 小值（如 1）：更强的串行语义，问题更易定位。
   - 大值：更高吞吐，但遇到卡住交易时可能挂更多 pending。

3. Gas 管理配置（transactions.handler.simple.*）
   gasOracle.mode：

   - disabled：禁用 Gas 预估，使用固定或默认值
   - connector：依赖节点默认值（eth_gasPrice 等）
   - restapi：调用外部 Gas Station 服务（由 url 和 template 控制）
   - fixed：使用静态 Gas 价格

   simple.fixedGasPrice：

   - 当 mode=fixed 时，用于指定固定 gas 单价。

   simple.resubmitInterval：

   - 重提交的间隔；太短会频繁重提，太长则卡住交易等待较久。

   confirmations.required：

   - 所需确认的区块数；与“何时认为交易最终成功”直接相关。

----------------------------------------------------------------------

通过 FFTM，Hyperledger FireFly 在以太坊 nonce 管理上实现了 完整而严谨的方案：
在 “源端”分配 nonce 并立即持久化，保证：

- 严格顺序
- 无重复 nonce
- 崩溃后可恢复，无丢/无多投

采用 单一 FFTM 实例 + 每地址锁 + 唯一性约束 的结构，确保每个账户的 nonce 序列是由 FireFly 全权掌控的，避免并发竞争和乱序。
借助 Transaction Handler 和 确认管理器：

- 自动处理 Gas 策略、卡住交易重提、确认等待与 reorg；
- 将链层复杂度对上层屏蔽，提供类似“数据库事务提交”的使用体验。

通过 持久化状态机与历史记录：

- 提供交易生命周期 360° 可观察性（AssignNonce → Submit → ReceiveReceipt → Confirm）。

通过 事件流 at-least-once + Core/合约层幂等性：

- 在存在网络抖动、重启、reorg 的情况下，仍能保证应用层不会被重复事件扰乱。

对于开发者和架构师而言，这意味着无需再自行实现复杂、易错的 nonce 跟踪与重试逻辑。FireFly 将常见的 "nonce too low"、"replacement underpriced"、"transaction stuck in pending" 等以太坊中的顽疾封装在平台内部，以 确定性、一致性和可恢复性 的方式交付给业务系统。

----------------------------------------------------------------------

崩溃恢复：

1. 状态初始化：查询 tx nonce 表以检索每个托管签名地址的游标，这个作为未来分配的起点。
2. 待处理工作识别：查询 transaction 表以查找所有当前处于 Allocated/Pending 或者 Mined/Submitted 状态的交易。
3. 幂等性恢复：恢复对所有已识别的待处理交易的监控，或者重新提交尝试。

重试逻辑和 Gas 管理：在 EVM 兼容区块链中，Gas 价格较低的交易可能会卡在内存池中，无法被挖矿。因为 Nonce 必须按顺序执行，所以停滞的低 Nonce 交易会有效地阻塞该地址的整个队列。

1. Gas 提价（Gas Bumping）：最常见的操作是使用相同的 Nonce，但提高 Gas 价格（或调整 EIP-1559 链的费用上限参数）重新提交交易。这种替换交易利用相同的 Nonce，保留了序列，同时激励矿工将其包含在内。
2. 替换/取消：用一个更高 Gas 价格、价值为零的交易替换掉原始 Nonce 的停滞交易，可以有效地“燃烧”该 Nonce，可以使后续交易继续进行。

实现了动态和知情的 Gas 价格调整，在不稳定的网络环境中维护严格“源端”排序保证完整性的强制性功能。

----------------------------------------------------------------------

Nonce 管理排他性
架构含义：当 FireFly 被迫共享密钥时，它必须牺牲其内部持久性提供的性能和绝对状态信心，转而依赖更慢、更不可靠的外部状态检查。
配置参数 transactions.nonceStateTimeout，专门用于解决无法保证绝对密钥排他性的场景。

默认/可靠模式（Timeout > 0）：

- 在此配置中，FFTM 依赖其持久的内部状态作为 next nonce 计数器。
- 这是最快且最可靠的模式，因为它将 Nonce 分配的关键路径与 RPC 网络延迟和外部节点可用性解耦。

折衷/互操作模式（Timeout 100ms）：

- 将超时设置为 0 或非常低的值会强制 FFTM Nonce 分配逻辑在每次分配请求时查询区块链节点的待
  处理交易池（Pending）。
- 它会检查外部状态，从而缩小因外部系统引起的并发 Nonce 冲突窗口，但它并不能完全消除冲突风险，
  并且会显著降低提交吞吐量并增加 RPC 节点的负载。